   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"udma.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.align	2
  19              		.global	uDMAEnable
  20              		.thumb
  21              		.thumb_func
  23              	uDMAEnable:
  24              	.LFB0:
  25              		.file 1 "build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c"
   1:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** /******************************************************************************
   2:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** *  Filename:       udma.c
   3:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** *  Revised:        $Date: 2013-03-20 14:47:53 +0100 (Wed, 20 Mar 2013) $
   4:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** *  Revision:       $Revision: 9489 $
   5:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** *
   6:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** *  Description:    Driver for the micro-DMA controller.
   7:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** *
   8:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** *  Copyright (C) 2012 Texas Instruments Incorporated - http://www.ti.com/
   9:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** *
  10:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** *
  11:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** *  Redistribution and use in source and binary forms, with or without
  12:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** *  modification, are permitted provided that the following conditions
  13:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** *  are met:
  14:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** *
  15:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** *    Redistributions of source code must retain the above copyright
  16:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** *    notice, this list of conditions and the following disclaimer.
  17:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** *
  18:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** *    Redistributions in binary form must reproduce the above copyright
  19:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** *    notice, this list of conditions and the following disclaimer in the
  20:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** *    documentation and/or other materials provided with the distribution.
  21:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** *
  22:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** *    Neither the name of Texas Instruments Incorporated nor the names of
  23:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** *    its contributors may be used to endorse or promote products derived
  24:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** *    from this software without specific prior written permission.
  25:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** *
  26:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  27:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  28:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  29:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  30:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  31:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  32:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  33:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  34:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  35:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  36:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  37:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** *
  38:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** ******************************************************************************/
  39:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
  40:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //*****************************************************************************
  41:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //
  42:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! \addtogroup udma_api
  43:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! @{
  44:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //
  45:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //*****************************************************************************
  46:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
  47:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** #include <headers/hw_sys_ctrl.h>
  48:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** #include <headers/hw_udma.h>
  49:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** #include <headers/hw_udmachctl.h>
  50:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** #include "debug.h"
  51:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** #include "interrupt.h"
  52:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** #include "udma.h"
  53:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
  54:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //*****************************************************************************
  55:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //
  56:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! Enables the uDMA controller for use
  57:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
  58:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! This function enables the uDMA controller.  The uDMA controller must be
  59:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! enabled before it can be configured and used.
  60:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
  61:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! \return None
  62:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //
  63:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //*****************************************************************************
  64:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** void
  65:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** uDMAEnable(void)
  66:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** {
  26              		.loc 1 66 0
  27              		.cfi_startproc
  28              		@ args = 0, pretend = 0, frame = 0
  29              		@ frame_needed = 1, uses_anonymous_args = 0
  30              		@ link register save eliminated.
  31 0000 80B4     		push	{r7}
  32              		.cfi_def_cfa_offset 4
  33              		.cfi_offset 7, -4
  34 0002 00AF     		add	r7, sp, #0
  35              		.cfi_def_cfa_register 7
  67:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
  68:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // Set the master enable bit in the config register.
  69:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
  70:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     HWREG(UDMA_CFG) = UDMA_CFG_MASTEN;
  36              		.loc 1 70 0
  37 0004 034B     		ldr	r3, .L2
  38 0006 0122     		movs	r2, #1
  39 0008 1A60     		str	r2, [r3]
  71:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** }
  40              		.loc 1 71 0
  41 000a BD46     		mov	sp, r7
  42              		.cfi_def_cfa_register 13
  43              		@ sp needed
  44 000c 5DF8047B 		ldr	r7, [sp], #4
  45              		.cfi_restore 7
  46              		.cfi_def_cfa_offset 0
  47 0010 7047     		bx	lr
  48              	.L3:
  49 0012 00BF     		.align	2
  50              	.L2:
  51 0014 04F00F40 		.word	1074786308
  52              		.cfi_endproc
  53              	.LFE0:
  55              		.align	2
  56              		.global	uDMADisable
  57              		.thumb
  58              		.thumb_func
  60              	uDMADisable:
  61              	.LFB1:
  72:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
  73:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //*****************************************************************************
  74:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //
  75:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! Disables the uDMA controller for use
  76:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
  77:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! This function disables the uDMA controller.  Once disabled, the uDMA
  78:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! controller will not operate until re-enabled with uDMAEnable().
  79:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
  80:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! \return None
  81:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //
  82:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //*****************************************************************************
  83:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** void
  84:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** uDMADisable(void)
  85:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** {
  62              		.loc 1 85 0
  63              		.cfi_startproc
  64              		@ args = 0, pretend = 0, frame = 0
  65              		@ frame_needed = 1, uses_anonymous_args = 0
  66              		@ link register save eliminated.
  67 0018 80B4     		push	{r7}
  68              		.cfi_def_cfa_offset 4
  69              		.cfi_offset 7, -4
  70 001a 00AF     		add	r7, sp, #0
  71              		.cfi_def_cfa_register 7
  86:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
  87:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // Clear the master enable bit in the config register.
  88:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
  89:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     HWREG(UDMA_CFG) = 0;
  72              		.loc 1 89 0
  73 001c 034B     		ldr	r3, .L5
  74 001e 0022     		movs	r2, #0
  75 0020 1A60     		str	r2, [r3]
  90:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** }
  76              		.loc 1 90 0
  77 0022 BD46     		mov	sp, r7
  78              		.cfi_def_cfa_register 13
  79              		@ sp needed
  80 0024 5DF8047B 		ldr	r7, [sp], #4
  81              		.cfi_restore 7
  82              		.cfi_def_cfa_offset 0
  83 0028 7047     		bx	lr
  84              	.L6:
  85 002a 00BF     		.align	2
  86              	.L5:
  87 002c 04F00F40 		.word	1074786308
  88              		.cfi_endproc
  89              	.LFE1:
  91              		.align	2
  92              		.global	uDMAErrorStatusGet
  93              		.thumb
  94              		.thumb_func
  96              	uDMAErrorStatusGet:
  97              	.LFB2:
  91:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
  92:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //*****************************************************************************
  93:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //
  94:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! Gets the uDMA error status
  95:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
  96:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! This function returns the uDMA error status.  It should be called from
  97:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! within the uDMA error interrupt handler to determine if a uDMA error
  98:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! occurred.
  99:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
 100:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! \return Returns non-zero if a uDMA error is pending.
 101:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //
 102:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //*****************************************************************************
 103:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** uint32_t
 104:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** uDMAErrorStatusGet(void)
 105:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** {
  98              		.loc 1 105 0
  99              		.cfi_startproc
 100              		@ args = 0, pretend = 0, frame = 0
 101              		@ frame_needed = 1, uses_anonymous_args = 0
 102              		@ link register save eliminated.
 103 0030 80B4     		push	{r7}
 104              		.cfi_def_cfa_offset 4
 105              		.cfi_offset 7, -4
 106 0032 00AF     		add	r7, sp, #0
 107              		.cfi_def_cfa_register 7
 106:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 107:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // Return the uDMA error status.
 108:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 109:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     return(HWREG(UDMA_ERRCLR));
 108              		.loc 1 109 0
 109 0034 034B     		ldr	r3, .L9
 110 0036 1B68     		ldr	r3, [r3]
 110:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** }
 111              		.loc 1 110 0
 112 0038 1846     		mov	r0, r3
 113 003a BD46     		mov	sp, r7
 114              		.cfi_def_cfa_register 13
 115              		@ sp needed
 116 003c 5DF8047B 		ldr	r7, [sp], #4
 117              		.cfi_restore 7
 118              		.cfi_def_cfa_offset 0
 119 0040 7047     		bx	lr
 120              	.L10:
 121 0042 00BF     		.align	2
 122              	.L9:
 123 0044 4CF00F40 		.word	1074786380
 124              		.cfi_endproc
 125              	.LFE2:
 127              		.align	2
 128              		.global	uDMAErrorStatusClear
 129              		.thumb
 130              		.thumb_func
 132              	uDMAErrorStatusClear:
 133              	.LFB3:
 111:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
 112:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //*****************************************************************************
 113:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //
 114:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! Clears the uDMA error interrupt
 115:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
 116:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! This function clears a pending uDMA error interrupt.  It should be called
 117:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! from within the uDMA error interrupt handler to clear the interrupt.
 118:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
 119:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! \return None
 120:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //
 121:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //*****************************************************************************
 122:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** void
 123:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** uDMAErrorStatusClear(void)
 124:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** {
 134              		.loc 1 124 0
 135              		.cfi_startproc
 136              		@ args = 0, pretend = 0, frame = 0
 137              		@ frame_needed = 1, uses_anonymous_args = 0
 138              		@ link register save eliminated.
 139 0048 80B4     		push	{r7}
 140              		.cfi_def_cfa_offset 4
 141              		.cfi_offset 7, -4
 142 004a 00AF     		add	r7, sp, #0
 143              		.cfi_def_cfa_register 7
 125:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 126:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // Clear the uDMA error interrupt.
 127:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 128:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     HWREG(UDMA_ERRCLR) = 1;
 144              		.loc 1 128 0
 145 004c 034B     		ldr	r3, .L12
 146 004e 0122     		movs	r2, #1
 147 0050 1A60     		str	r2, [r3]
 129:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** }
 148              		.loc 1 129 0
 149 0052 BD46     		mov	sp, r7
 150              		.cfi_def_cfa_register 13
 151              		@ sp needed
 152 0054 5DF8047B 		ldr	r7, [sp], #4
 153              		.cfi_restore 7
 154              		.cfi_def_cfa_offset 0
 155 0058 7047     		bx	lr
 156              	.L13:
 157 005a 00BF     		.align	2
 158              	.L12:
 159 005c 4CF00F40 		.word	1074786380
 160              		.cfi_endproc
 161              	.LFE3:
 163              		.align	2
 164              		.global	uDMAChannelEnable
 165              		.thumb
 166              		.thumb_func
 168              	uDMAChannelEnable:
 169              	.LFB4:
 130:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
 131:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //*****************************************************************************
 132:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //
 133:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! Enables a uDMA channel for operation
 134:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
 135:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! \param ui32ChannelNum is the channel number to enable.
 136:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
 137:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! This function enables a specific uDMA channel for use.  This function must
 138:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! be used to enable a channel before it can be used to perform a uDMA
 139:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! transfer.
 140:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
 141:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! When a uDMA transfer is completed, the channel will be automatically
 142:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! disabled by the uDMA controller.  Therefore, this function should be called
 143:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! prior to starting up any new transfer.
 144:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
 145:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! \return None
 146:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //
 147:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //*****************************************************************************
 148:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** void
 149:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** uDMAChannelEnable(uint32_t ui32ChannelNum)
 150:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** {
 170              		.loc 1 150 0
 171              		.cfi_startproc
 172              		@ args = 0, pretend = 0, frame = 8
 173              		@ frame_needed = 1, uses_anonymous_args = 0
 174              		@ link register save eliminated.
 175 0060 80B4     		push	{r7}
 176              		.cfi_def_cfa_offset 4
 177              		.cfi_offset 7, -4
 178 0062 83B0     		sub	sp, sp, #12
 179              		.cfi_def_cfa_offset 16
 180 0064 00AF     		add	r7, sp, #0
 181              		.cfi_def_cfa_register 7
 182 0066 7860     		str	r0, [r7, #4]
 151:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 152:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // Check the arguments.
 153:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 154:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     ASSERT((ui32ChannelNum & 0xffff) < 32);
 155:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
 156:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 157:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // Set the bit for this channel in the enable set register.
 158:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 159:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     HWREG(UDMA_ENASET) = 1 << (ui32ChannelNum & 0x1f);
 183              		.loc 1 159 0
 184 0068 064A     		ldr	r2, .L15
 185 006a 7B68     		ldr	r3, [r7, #4]
 186 006c 03F01F03 		and	r3, r3, #31
 187 0070 0121     		movs	r1, #1
 188 0072 01FA03F3 		lsl	r3, r1, r3
 189 0076 1360     		str	r3, [r2]
 160:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** }
 190              		.loc 1 160 0
 191 0078 0C37     		adds	r7, r7, #12
 192              		.cfi_def_cfa_offset 4
 193 007a BD46     		mov	sp, r7
 194              		.cfi_def_cfa_register 13
 195              		@ sp needed
 196 007c 5DF8047B 		ldr	r7, [sp], #4
 197              		.cfi_restore 7
 198              		.cfi_def_cfa_offset 0
 199 0080 7047     		bx	lr
 200              	.L16:
 201 0082 00BF     		.align	2
 202              	.L15:
 203 0084 28F00F40 		.word	1074786344
 204              		.cfi_endproc
 205              	.LFE4:
 207              		.align	2
 208              		.global	uDMAChannelDisable
 209              		.thumb
 210              		.thumb_func
 212              	uDMAChannelDisable:
 213              	.LFB5:
 161:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
 162:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //*****************************************************************************
 163:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //
 164:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! Disables a uDMA channel for operation
 165:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
 166:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! \param ui32ChannelNum is the channel number to disable.
 167:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
 168:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! This function disables a specific uDMA channel.  Once disabled, a channel
 169:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! will not respond to uDMA transfer requests until re-enabled via
 170:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! uDMAChannelEnable().
 171:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
 172:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! \return None
 173:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //
 174:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //*****************************************************************************
 175:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** void
 176:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** uDMAChannelDisable(uint32_t ui32ChannelNum)
 177:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** {
 214              		.loc 1 177 0
 215              		.cfi_startproc
 216              		@ args = 0, pretend = 0, frame = 8
 217              		@ frame_needed = 1, uses_anonymous_args = 0
 218              		@ link register save eliminated.
 219 0088 80B4     		push	{r7}
 220              		.cfi_def_cfa_offset 4
 221              		.cfi_offset 7, -4
 222 008a 83B0     		sub	sp, sp, #12
 223              		.cfi_def_cfa_offset 16
 224 008c 00AF     		add	r7, sp, #0
 225              		.cfi_def_cfa_register 7
 226 008e 7860     		str	r0, [r7, #4]
 178:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 179:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // Check the arguments.
 180:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 181:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     ASSERT((ui32ChannelNum & 0xffff) < 32);
 182:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
 183:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 184:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // Set the bit for this channel in the enable clear register.
 185:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 186:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     HWREG(UDMA_ENACLR) = 1 << (ui32ChannelNum & 0x1f);
 227              		.loc 1 186 0
 228 0090 064A     		ldr	r2, .L18
 229 0092 7B68     		ldr	r3, [r7, #4]
 230 0094 03F01F03 		and	r3, r3, #31
 231 0098 0121     		movs	r1, #1
 232 009a 01FA03F3 		lsl	r3, r1, r3
 233 009e 1360     		str	r3, [r2]
 187:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** }
 234              		.loc 1 187 0
 235 00a0 0C37     		adds	r7, r7, #12
 236              		.cfi_def_cfa_offset 4
 237 00a2 BD46     		mov	sp, r7
 238              		.cfi_def_cfa_register 13
 239              		@ sp needed
 240 00a4 5DF8047B 		ldr	r7, [sp], #4
 241              		.cfi_restore 7
 242              		.cfi_def_cfa_offset 0
 243 00a8 7047     		bx	lr
 244              	.L19:
 245 00aa 00BF     		.align	2
 246              	.L18:
 247 00ac 2CF00F40 		.word	1074786348
 248              		.cfi_endproc
 249              	.LFE5:
 251              		.align	2
 252              		.global	uDMAChannelIsEnabled
 253              		.thumb
 254              		.thumb_func
 256              	uDMAChannelIsEnabled:
 257              	.LFB6:
 188:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
 189:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //*****************************************************************************
 190:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //
 191:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! Checks if a uDMA channel is enabled for operation
 192:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
 193:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! \param ui32ChannelNum is the channel number to check.
 194:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
 195:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! This function checks to see if a specific uDMA channel is enabled.  This
 196:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! can be used to check the status of a transfer, since the channel will
 197:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! be automatically disabled at the end of a transfer.
 198:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
 199:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! \return Returns \b true if the channel is enabled, \b false if disabled.
 200:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //
 201:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //*****************************************************************************
 202:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** bool
 203:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** uDMAChannelIsEnabled(uint32_t ui32ChannelNum)
 204:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** {
 258              		.loc 1 204 0
 259              		.cfi_startproc
 260              		@ args = 0, pretend = 0, frame = 8
 261              		@ frame_needed = 1, uses_anonymous_args = 0
 262              		@ link register save eliminated.
 263 00b0 80B4     		push	{r7}
 264              		.cfi_def_cfa_offset 4
 265              		.cfi_offset 7, -4
 266 00b2 83B0     		sub	sp, sp, #12
 267              		.cfi_def_cfa_offset 16
 268 00b4 00AF     		add	r7, sp, #0
 269              		.cfi_def_cfa_register 7
 270 00b6 7860     		str	r0, [r7, #4]
 205:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 206:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // Check the arguments.
 207:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 208:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     ASSERT((ui32ChannelNum & 0xffff) < 32);
 209:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
 210:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 211:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // AND the specified channel bit with the enable register, and return the
 212:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // result.
 213:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 214:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
 215:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     return((HWREG(UDMA_ENASET) & (1 << (ui32ChannelNum & 0x1f))) ? true : false);
 271              		.loc 1 215 0
 272 00b8 094B     		ldr	r3, .L22
 273 00ba 1B68     		ldr	r3, [r3]
 274 00bc 7A68     		ldr	r2, [r7, #4]
 275 00be 02F01F02 		and	r2, r2, #31
 276 00c2 0121     		movs	r1, #1
 277 00c4 01FA02F2 		lsl	r2, r1, r2
 278 00c8 1340     		ands	r3, r3, r2
 279 00ca 002B     		cmp	r3, #0
 280 00cc 14BF     		ite	ne
 281 00ce 0123     		movne	r3, #1
 282 00d0 0023     		moveq	r3, #0
 283 00d2 DBB2     		uxtb	r3, r3
 216:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** }
 284              		.loc 1 216 0
 285 00d4 1846     		mov	r0, r3
 286 00d6 0C37     		adds	r7, r7, #12
 287              		.cfi_def_cfa_offset 4
 288 00d8 BD46     		mov	sp, r7
 289              		.cfi_def_cfa_register 13
 290              		@ sp needed
 291 00da 5DF8047B 		ldr	r7, [sp], #4
 292              		.cfi_restore 7
 293              		.cfi_def_cfa_offset 0
 294 00de 7047     		bx	lr
 295              	.L23:
 296              		.align	2
 297              	.L22:
 298 00e0 28F00F40 		.word	1074786344
 299              		.cfi_endproc
 300              	.LFE6:
 302              		.align	2
 303              		.global	uDMAControlBaseSet
 304              		.thumb
 305              		.thumb_func
 307              	uDMAControlBaseSet:
 308              	.LFB7:
 217:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
 218:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //*****************************************************************************
 219:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //
 220:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! Sets the base address for the channel control table
 221:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
 222:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! \param pControlTable is a pointer to the 1024 byte aligned base address
 223:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! of the uDMA channel control table.
 224:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
 225:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! This function sets the base address of the channel control table.  This
 226:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! table resides in system memory and holds control information for each uDMA
 227:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! channel.  The table must be aligned on a 1024 byte boundary.  The base
 228:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! address must be set before any of the channel functions can be used.
 229:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
 230:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! The size of the channel control table depends on the number of uDMA
 231:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! channels, and which transfer modes are used.  Refer to the introductory
 232:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! text and the microcontroller datasheet for more information about the
 233:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! channel control table.
 234:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
 235:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! \return None
 236:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //
 237:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //*****************************************************************************
 238:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** void
 239:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** uDMAControlBaseSet(void *pControlTable)
 240:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** {
 309              		.loc 1 240 0
 310              		.cfi_startproc
 311              		@ args = 0, pretend = 0, frame = 8
 312              		@ frame_needed = 1, uses_anonymous_args = 0
 313              		@ link register save eliminated.
 314 00e4 80B4     		push	{r7}
 315              		.cfi_def_cfa_offset 4
 316              		.cfi_offset 7, -4
 317 00e6 83B0     		sub	sp, sp, #12
 318              		.cfi_def_cfa_offset 16
 319 00e8 00AF     		add	r7, sp, #0
 320              		.cfi_def_cfa_register 7
 321 00ea 7860     		str	r0, [r7, #4]
 241:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 242:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // Check the arguments.
 243:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 244:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     ASSERT(((uint32_t)pControlTable & ~0x3FF) ==
 245:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****            (uint32_t)pControlTable);
 246:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     ASSERT((uint32_t)pControlTable >= 0x20000000);
 247:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
 248:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 249:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // Program the base address into the register.
 250:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 251:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     HWREG(UDMA_CTLBASE) = (uint32_t)pControlTable;
 322              		.loc 1 251 0
 323 00ec 034A     		ldr	r2, .L25
 324 00ee 7B68     		ldr	r3, [r7, #4]
 325 00f0 1360     		str	r3, [r2]
 252:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** }
 326              		.loc 1 252 0
 327 00f2 0C37     		adds	r7, r7, #12
 328              		.cfi_def_cfa_offset 4
 329 00f4 BD46     		mov	sp, r7
 330              		.cfi_def_cfa_register 13
 331              		@ sp needed
 332 00f6 5DF8047B 		ldr	r7, [sp], #4
 333              		.cfi_restore 7
 334              		.cfi_def_cfa_offset 0
 335 00fa 7047     		bx	lr
 336              	.L26:
 337              		.align	2
 338              	.L25:
 339 00fc 08F00F40 		.word	1074786312
 340              		.cfi_endproc
 341              	.LFE7:
 343              		.align	2
 344              		.global	uDMAControlBaseGet
 345              		.thumb
 346              		.thumb_func
 348              	uDMAControlBaseGet:
 349              	.LFB8:
 253:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
 254:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //*****************************************************************************
 255:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //
 256:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! Gets the base address for the channel control table
 257:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
 258:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! This function gets the base address of the channel control table.  This
 259:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! table resides in system memory and holds control information for each uDMA
 260:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! channel.
 261:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
 262:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! \return Returns a pointer to the base address of the channel control table.
 263:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //
 264:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //*****************************************************************************
 265:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** void *
 266:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** uDMAControlBaseGet(void)
 267:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** {
 350              		.loc 1 267 0
 351              		.cfi_startproc
 352              		@ args = 0, pretend = 0, frame = 0
 353              		@ frame_needed = 1, uses_anonymous_args = 0
 354              		@ link register save eliminated.
 355 0100 80B4     		push	{r7}
 356              		.cfi_def_cfa_offset 4
 357              		.cfi_offset 7, -4
 358 0102 00AF     		add	r7, sp, #0
 359              		.cfi_def_cfa_register 7
 268:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 269:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // Read the current value of the control base register, and return it to
 270:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // the caller.
 271:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 272:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     return((void *)HWREG(UDMA_CTLBASE));
 360              		.loc 1 272 0
 361 0104 034B     		ldr	r3, .L29
 362 0106 1B68     		ldr	r3, [r3]
 273:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** }
 363              		.loc 1 273 0
 364 0108 1846     		mov	r0, r3
 365 010a BD46     		mov	sp, r7
 366              		.cfi_def_cfa_register 13
 367              		@ sp needed
 368 010c 5DF8047B 		ldr	r7, [sp], #4
 369              		.cfi_restore 7
 370              		.cfi_def_cfa_offset 0
 371 0110 7047     		bx	lr
 372              	.L30:
 373 0112 00BF     		.align	2
 374              	.L29:
 375 0114 08F00F40 		.word	1074786312
 376              		.cfi_endproc
 377              	.LFE8:
 379              		.align	2
 380              		.global	uDMAControlAlternateBaseGet
 381              		.thumb
 382              		.thumb_func
 384              	uDMAControlAlternateBaseGet:
 385              	.LFB9:
 274:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
 275:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //*****************************************************************************
 276:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //
 277:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! Gets the base address for the channel control table alternate structures
 278:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
 279:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! This function gets the base address of the second half of the channel
 280:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! control table that holds the alternate control structures for each channel.
 281:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
 282:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! \return Returns a pointer to the base address of the second half of the
 283:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! channel control table.
 284:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //
 285:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //*****************************************************************************
 286:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** void *
 287:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** uDMAControlAlternateBaseGet(void)
 288:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** {
 386              		.loc 1 288 0
 387              		.cfi_startproc
 388              		@ args = 0, pretend = 0, frame = 0
 389              		@ frame_needed = 1, uses_anonymous_args = 0
 390              		@ link register save eliminated.
 391 0118 80B4     		push	{r7}
 392              		.cfi_def_cfa_offset 4
 393              		.cfi_offset 7, -4
 394 011a 00AF     		add	r7, sp, #0
 395              		.cfi_def_cfa_register 7
 289:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 290:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // Read the current value of the control base register, and return it to
 291:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // the caller.
 292:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 293:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     return((void *)HWREG(UDMA_ALTBASE));
 396              		.loc 1 293 0
 397 011c 034B     		ldr	r3, .L33
 398 011e 1B68     		ldr	r3, [r3]
 294:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** }
 399              		.loc 1 294 0
 400 0120 1846     		mov	r0, r3
 401 0122 BD46     		mov	sp, r7
 402              		.cfi_def_cfa_register 13
 403              		@ sp needed
 404 0124 5DF8047B 		ldr	r7, [sp], #4
 405              		.cfi_restore 7
 406              		.cfi_def_cfa_offset 0
 407 0128 7047     		bx	lr
 408              	.L34:
 409 012a 00BF     		.align	2
 410              	.L33:
 411 012c 0CF00F40 		.word	1074786316
 412              		.cfi_endproc
 413              	.LFE9:
 415              		.align	2
 416              		.global	uDMAChannelRequest
 417              		.thumb
 418              		.thumb_func
 420              	uDMAChannelRequest:
 421              	.LFB10:
 295:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
 296:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //*****************************************************************************
 297:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //
 298:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! Requests a uDMA channel to start a transfer
 299:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
 300:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! \param ui32ChannelNum is the channel number on which to request a uDMA
 301:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! transfer.
 302:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
 303:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! This function allows software to request a uDMA channel to begin a
 304:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! transfer.  This could be used for performing a memory to memory transfer,
 305:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! or if for some reason a transfer needs to be initiated by software instead
 306:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! of the peripheral associated with that channel.
 307:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
 308:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! \note If the channel is \b UDMA_CH30_SW and interrupts
 309:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! are used, then the completion will be signaled on the uDMA dedicated
 310:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! interrupt.
 311:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! If a peripheral channel is used, then the completion will be signaled on the
 312:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! peripheral's interrupt.
 313:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
 314:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! \return None
 315:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //
 316:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //*****************************************************************************
 317:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** void
 318:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** uDMAChannelRequest(uint32_t ui32ChannelNum)
 319:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** {
 422              		.loc 1 319 0
 423              		.cfi_startproc
 424              		@ args = 0, pretend = 0, frame = 8
 425              		@ frame_needed = 1, uses_anonymous_args = 0
 426              		@ link register save eliminated.
 427 0130 80B4     		push	{r7}
 428              		.cfi_def_cfa_offset 4
 429              		.cfi_offset 7, -4
 430 0132 83B0     		sub	sp, sp, #12
 431              		.cfi_def_cfa_offset 16
 432 0134 00AF     		add	r7, sp, #0
 433              		.cfi_def_cfa_register 7
 434 0136 7860     		str	r0, [r7, #4]
 320:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 321:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // Check the arguments.
 322:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 323:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     ASSERT((ui32ChannelNum & 0xffff) < 32);
 324:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
 325:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 326:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // Set the bit for this channel in the software uDMA request register.
 327:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 328:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     HWREG(UDMA_SWREQ) = 1 << (ui32ChannelNum & 0x1f);
 435              		.loc 1 328 0
 436 0138 064A     		ldr	r2, .L36
 437 013a 7B68     		ldr	r3, [r7, #4]
 438 013c 03F01F03 		and	r3, r3, #31
 439 0140 0121     		movs	r1, #1
 440 0142 01FA03F3 		lsl	r3, r1, r3
 441 0146 1360     		str	r3, [r2]
 329:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** }
 442              		.loc 1 329 0
 443 0148 0C37     		adds	r7, r7, #12
 444              		.cfi_def_cfa_offset 4
 445 014a BD46     		mov	sp, r7
 446              		.cfi_def_cfa_register 13
 447              		@ sp needed
 448 014c 5DF8047B 		ldr	r7, [sp], #4
 449              		.cfi_restore 7
 450              		.cfi_def_cfa_offset 0
 451 0150 7047     		bx	lr
 452              	.L37:
 453 0152 00BF     		.align	2
 454              	.L36:
 455 0154 14F00F40 		.word	1074786324
 456              		.cfi_endproc
 457              	.LFE10:
 459              		.align	2
 460              		.global	uDMAChannelAttributeEnable
 461              		.thumb
 462              		.thumb_func
 464              	uDMAChannelAttributeEnable:
 465              	.LFB11:
 330:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
 331:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //*****************************************************************************
 332:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //
 333:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! Enables attributes of a uDMA channel
 334:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
 335:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! \param ui32ChannelNum is the channel to configure.
 336:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! \param ui32Attr is a combination of attributes for the channel.
 337:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
 338:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! This function is used to enable attributes of a uDMA channel.
 339:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
 340:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! The \e ui32Attr parameter is the logical OR of any of the following:
 341:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
 342:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! - \b UDMA_ATTR_USEBURST is used to restrict transfers to use only a burst
 343:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!   mode.
 344:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! - \b UDMA_ATTR_ALTSELECT is used to select the alternate control structure
 345:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!   for this channel (it is very unlikely that this flag should be used).
 346:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! - \b UDMA_ATTR_HIGH_PRIORITY is used to set this channel to high priority.
 347:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! - \b UDMA_ATTR_REQMASK is used to mask the hardware request signal from the
 348:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!   peripheral for this channel.
 349:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
 350:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! \return None
 351:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //
 352:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //*****************************************************************************
 353:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** void
 354:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** uDMAChannelAttributeEnable(uint32_t ui32ChannelNum, uint32_t ui32Attr)
 355:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** {
 466              		.loc 1 355 0
 467              		.cfi_startproc
 468              		@ args = 0, pretend = 0, frame = 8
 469              		@ frame_needed = 1, uses_anonymous_args = 0
 470              		@ link register save eliminated.
 471 0158 80B4     		push	{r7}
 472              		.cfi_def_cfa_offset 4
 473              		.cfi_offset 7, -4
 474 015a 83B0     		sub	sp, sp, #12
 475              		.cfi_def_cfa_offset 16
 476 015c 00AF     		add	r7, sp, #0
 477              		.cfi_def_cfa_register 7
 478 015e 7860     		str	r0, [r7, #4]
 479 0160 3960     		str	r1, [r7]
 356:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 357:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // Check the arguments.
 358:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 359:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     ASSERT((ui32ChannelNum & 0xffff) < 32);
 360:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     ASSERT((ui32Attr & ~(UDMA_ATTR_USEBURST | UDMA_ATTR_ALTSELECT |
 361:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****                          UDMA_ATTR_HIGH_PRIORITY | UDMA_ATTR_REQMASK)) == 0);
 362:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
 363:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 364:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // In case a channel selector macro (like UDMA_CH0_USB0EP1RX) was
 365:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // passed as the ui32ChannelNum parameter, extract just the channel number
 366:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // from this parameter.
 367:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 368:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     ui32ChannelNum &= 0x1f;
 480              		.loc 1 368 0
 481 0162 7B68     		ldr	r3, [r7, #4]
 482 0164 03F01F03 		and	r3, r3, #31
 483 0168 7B60     		str	r3, [r7, #4]
 369:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
 370:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 371:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // Set the useburst bit for this channel if set in ui32Config.
 372:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 373:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     if(ui32Attr & UDMA_ATTR_USEBURST)
 484              		.loc 1 373 0
 485 016a 3B68     		ldr	r3, [r7]
 486 016c 03F00103 		and	r3, r3, #1
 487 0170 002B     		cmp	r3, #0
 488 0172 05D0     		beq	.L39
 374:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     {
 375:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****         HWREG(UDMA_USEBURSTSET) = 1 << ui32ChannelNum;
 489              		.loc 1 375 0
 490 0174 154A     		ldr	r2, .L43
 491 0176 7B68     		ldr	r3, [r7, #4]
 492 0178 0121     		movs	r1, #1
 493 017a 01FA03F3 		lsl	r3, r1, r3
 494 017e 1360     		str	r3, [r2]
 495              	.L39:
 376:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     }
 377:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
 378:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 379:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // Set the alternate control select bit for this channel,
 380:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // if set in ui32Config.
 381:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 382:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     if(ui32Attr & UDMA_ATTR_ALTSELECT)
 496              		.loc 1 382 0
 497 0180 3B68     		ldr	r3, [r7]
 498 0182 03F00203 		and	r3, r3, #2
 499 0186 002B     		cmp	r3, #0
 500 0188 05D0     		beq	.L40
 383:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     {
 384:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****         HWREG(UDMA_ALTSET) = 1 << ui32ChannelNum;
 501              		.loc 1 384 0
 502 018a 114A     		ldr	r2, .L43+4
 503 018c 7B68     		ldr	r3, [r7, #4]
 504 018e 0121     		movs	r1, #1
 505 0190 01FA03F3 		lsl	r3, r1, r3
 506 0194 1360     		str	r3, [r2]
 507              	.L40:
 385:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     }
 386:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
 387:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 388:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // Set the high priority bit for this channel, if set in ui32Config.
 389:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 390:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     if(ui32Attr & UDMA_ATTR_HIGH_PRIORITY)
 508              		.loc 1 390 0
 509 0196 3B68     		ldr	r3, [r7]
 510 0198 03F00403 		and	r3, r3, #4
 511 019c 002B     		cmp	r3, #0
 512 019e 05D0     		beq	.L41
 391:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     {
 392:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****         HWREG(UDMA_PRIOSET) = 1 << ui32ChannelNum;
 513              		.loc 1 392 0
 514 01a0 0C4A     		ldr	r2, .L43+8
 515 01a2 7B68     		ldr	r3, [r7, #4]
 516 01a4 0121     		movs	r1, #1
 517 01a6 01FA03F3 		lsl	r3, r1, r3
 518 01aa 1360     		str	r3, [r2]
 519              	.L41:
 393:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     }
 394:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
 395:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 396:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // Set the request mask bit for this channel, if set in ui32Config.
 397:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 398:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     if(ui32Attr & UDMA_ATTR_REQMASK)
 520              		.loc 1 398 0
 521 01ac 3B68     		ldr	r3, [r7]
 522 01ae 03F00803 		and	r3, r3, #8
 523 01b2 002B     		cmp	r3, #0
 524 01b4 05D0     		beq	.L38
 399:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     {
 400:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****         HWREG(UDMA_REQMASKSET) = 1 << ui32ChannelNum;
 525              		.loc 1 400 0
 526 01b6 084A     		ldr	r2, .L43+12
 527 01b8 7B68     		ldr	r3, [r7, #4]
 528 01ba 0121     		movs	r1, #1
 529 01bc 01FA03F3 		lsl	r3, r1, r3
 530 01c0 1360     		str	r3, [r2]
 531              	.L38:
 401:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     }
 402:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** }
 532              		.loc 1 402 0
 533 01c2 0C37     		adds	r7, r7, #12
 534              		.cfi_def_cfa_offset 4
 535 01c4 BD46     		mov	sp, r7
 536              		.cfi_def_cfa_register 13
 537              		@ sp needed
 538 01c6 5DF8047B 		ldr	r7, [sp], #4
 539              		.cfi_restore 7
 540              		.cfi_def_cfa_offset 0
 541 01ca 7047     		bx	lr
 542              	.L44:
 543              		.align	2
 544              	.L43:
 545 01cc 18F00F40 		.word	1074786328
 546 01d0 30F00F40 		.word	1074786352
 547 01d4 38F00F40 		.word	1074786360
 548 01d8 20F00F40 		.word	1074786336
 549              		.cfi_endproc
 550              	.LFE11:
 552              		.align	2
 553              		.global	uDMAChannelAttributeDisable
 554              		.thumb
 555              		.thumb_func
 557              	uDMAChannelAttributeDisable:
 558              	.LFB12:
 403:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
 404:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //*****************************************************************************
 405:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //
 406:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! Disables attributes of a uDMA channel
 407:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
 408:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! \param ui32ChannelNum is the channel to configure.
 409:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! \param ui32Attr is a combination of attributes for the channel.
 410:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
 411:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! This function is used to disable attributes of a uDMA channel.
 412:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
 413:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! The \e ui32Attr parameter is the logical OR of any of the following:
 414:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
 415:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! - \b UDMA_ATTR_USEBURST is used to restrict transfers to use only a burst
 416:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!   mode.
 417:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! - \b UDMA_ATTR_ALTSELECT is used to select the alternate control structure
 418:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!   for this channel.
 419:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! - \b UDMA_ATTR_HIGH_PRIORITY is used to set this channel to high priority.
 420:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! - \b UDMA_ATTR_REQMASK is used to mask the hardware request signal from the
 421:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!   peripheral for this channel.
 422:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
 423:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! \return None
 424:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //
 425:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //*****************************************************************************
 426:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** void
 427:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** uDMAChannelAttributeDisable(uint32_t ui32ChannelNum, uint32_t ui32Attr)
 428:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** {
 559              		.loc 1 428 0
 560              		.cfi_startproc
 561              		@ args = 0, pretend = 0, frame = 8
 562              		@ frame_needed = 1, uses_anonymous_args = 0
 563              		@ link register save eliminated.
 564 01dc 80B4     		push	{r7}
 565              		.cfi_def_cfa_offset 4
 566              		.cfi_offset 7, -4
 567 01de 83B0     		sub	sp, sp, #12
 568              		.cfi_def_cfa_offset 16
 569 01e0 00AF     		add	r7, sp, #0
 570              		.cfi_def_cfa_register 7
 571 01e2 7860     		str	r0, [r7, #4]
 572 01e4 3960     		str	r1, [r7]
 429:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 430:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // Check the arguments.
 431:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 432:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     ASSERT((ui32ChannelNum & 0xffff) < 32);
 433:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     ASSERT((ui32Attr & ~(UDMA_ATTR_USEBURST | UDMA_ATTR_ALTSELECT |
 434:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****                          UDMA_ATTR_HIGH_PRIORITY | UDMA_ATTR_REQMASK)) == 0);
 435:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
 436:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 437:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // In case a channel selector macro (like UDMA_CH0_USB0EP1RX) was
 438:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // passed as the ui32ChannelNum parameter, extract just the channel number
 439:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // from this parameter.
 440:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 441:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     ui32ChannelNum &= 0x1f;
 573              		.loc 1 441 0
 574 01e6 7B68     		ldr	r3, [r7, #4]
 575 01e8 03F01F03 		and	r3, r3, #31
 576 01ec 7B60     		str	r3, [r7, #4]
 442:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
 443:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 444:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // Clear the useburst bit for this channel if set in ui32Config.
 445:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 446:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     if(ui32Attr & UDMA_ATTR_USEBURST)
 577              		.loc 1 446 0
 578 01ee 3B68     		ldr	r3, [r7]
 579 01f0 03F00103 		and	r3, r3, #1
 580 01f4 002B     		cmp	r3, #0
 581 01f6 05D0     		beq	.L46
 447:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     {
 448:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****         HWREG(UDMA_USEBURSTCLR) = 1 << ui32ChannelNum;
 582              		.loc 1 448 0
 583 01f8 154A     		ldr	r2, .L50
 584 01fa 7B68     		ldr	r3, [r7, #4]
 585 01fc 0121     		movs	r1, #1
 586 01fe 01FA03F3 		lsl	r3, r1, r3
 587 0202 1360     		str	r3, [r2]
 588              	.L46:
 449:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     }
 450:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
 451:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 452:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // Clear the alternate control select bit for this channel, if set in
 453:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // ui32Config.
 454:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 455:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     if(ui32Attr & UDMA_ATTR_ALTSELECT)
 589              		.loc 1 455 0
 590 0204 3B68     		ldr	r3, [r7]
 591 0206 03F00203 		and	r3, r3, #2
 592 020a 002B     		cmp	r3, #0
 593 020c 05D0     		beq	.L47
 456:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     {
 457:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****         HWREG(UDMA_ALTCLR) = 1 << ui32ChannelNum;
 594              		.loc 1 457 0
 595 020e 114A     		ldr	r2, .L50+4
 596 0210 7B68     		ldr	r3, [r7, #4]
 597 0212 0121     		movs	r1, #1
 598 0214 01FA03F3 		lsl	r3, r1, r3
 599 0218 1360     		str	r3, [r2]
 600              	.L47:
 458:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     }
 459:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
 460:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 461:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // Clear the high priority bit for this channel, if set in ui32Config.
 462:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 463:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     if(ui32Attr & UDMA_ATTR_HIGH_PRIORITY)
 601              		.loc 1 463 0
 602 021a 3B68     		ldr	r3, [r7]
 603 021c 03F00403 		and	r3, r3, #4
 604 0220 002B     		cmp	r3, #0
 605 0222 05D0     		beq	.L48
 464:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     {
 465:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****         HWREG(UDMA_PRIOCLR) = 1 << ui32ChannelNum;
 606              		.loc 1 465 0
 607 0224 0C4A     		ldr	r2, .L50+8
 608 0226 7B68     		ldr	r3, [r7, #4]
 609 0228 0121     		movs	r1, #1
 610 022a 01FA03F3 		lsl	r3, r1, r3
 611 022e 1360     		str	r3, [r2]
 612              	.L48:
 466:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     }
 467:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
 468:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 469:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // Clear the request mask bit for this channel, if set in ui32Config.
 470:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 471:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     if(ui32Attr & UDMA_ATTR_REQMASK)
 613              		.loc 1 471 0
 614 0230 3B68     		ldr	r3, [r7]
 615 0232 03F00803 		and	r3, r3, #8
 616 0236 002B     		cmp	r3, #0
 617 0238 05D0     		beq	.L45
 472:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     {
 473:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****         HWREG(UDMA_REQMASKCLR) = 1 << ui32ChannelNum;
 618              		.loc 1 473 0
 619 023a 084A     		ldr	r2, .L50+12
 620 023c 7B68     		ldr	r3, [r7, #4]
 621 023e 0121     		movs	r1, #1
 622 0240 01FA03F3 		lsl	r3, r1, r3
 623 0244 1360     		str	r3, [r2]
 624              	.L45:
 474:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     }
 475:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** }
 625              		.loc 1 475 0
 626 0246 0C37     		adds	r7, r7, #12
 627              		.cfi_def_cfa_offset 4
 628 0248 BD46     		mov	sp, r7
 629              		.cfi_def_cfa_register 13
 630              		@ sp needed
 631 024a 5DF8047B 		ldr	r7, [sp], #4
 632              		.cfi_restore 7
 633              		.cfi_def_cfa_offset 0
 634 024e 7047     		bx	lr
 635              	.L51:
 636              		.align	2
 637              	.L50:
 638 0250 1CF00F40 		.word	1074786332
 639 0254 34F00F40 		.word	1074786356
 640 0258 3CF00F40 		.word	1074786364
 641 025c 24F00F40 		.word	1074786340
 642              		.cfi_endproc
 643              	.LFE12:
 645              		.align	2
 646              		.global	uDMAChannelAttributeGet
 647              		.thumb
 648              		.thumb_func
 650              	uDMAChannelAttributeGet:
 651              	.LFB13:
 476:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
 477:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //*****************************************************************************
 478:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //
 479:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! Gets the enabled attributes of a uDMA channel
 480:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
 481:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! \param ui32ChannelNum is the channel to configure.
 482:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
 483:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! This function returns a combination of flags representing the attributes of
 484:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! the uDMA channel.
 485:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
 486:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! \return Returns the logical OR of the attributes of the uDMA channel, which
 487:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! can be any of the following:
 488:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! - \b UDMA_ATTR_USEBURST is used to restrict transfers to use only a burst
 489:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!   mode.
 490:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! - \b UDMA_ATTR_ALTSELECT is used to select the alternate control structure
 491:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!   for this channel.
 492:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! - \b UDMA_ATTR_HIGH_PRIORITY is used to set this channel to high priority.
 493:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! - \b UDMA_ATTR_REQMASK is used to mask the hardware request signal from the
 494:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!   peripheral for this channel.
 495:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //
 496:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //*****************************************************************************
 497:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** uint32_t
 498:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** uDMAChannelAttributeGet(uint32_t ui32ChannelNum)
 499:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** {
 652              		.loc 1 499 0
 653              		.cfi_startproc
 654              		@ args = 0, pretend = 0, frame = 16
 655              		@ frame_needed = 1, uses_anonymous_args = 0
 656              		@ link register save eliminated.
 657 0260 80B4     		push	{r7}
 658              		.cfi_def_cfa_offset 4
 659              		.cfi_offset 7, -4
 660 0262 85B0     		sub	sp, sp, #20
 661              		.cfi_def_cfa_offset 24
 662 0264 00AF     		add	r7, sp, #0
 663              		.cfi_def_cfa_register 7
 664 0266 7860     		str	r0, [r7, #4]
 500:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     uint32_t ui32Attr = 0;
 665              		.loc 1 500 0
 666 0268 0023     		movs	r3, #0
 667 026a FB60     		str	r3, [r7, #12]
 501:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
 502:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 503:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // Check the arguments.
 504:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 505:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     ASSERT((ui32ChannelNum & 0xffff) < 32);
 506:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
 507:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 508:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // In case a channel selector macro (like UDMA_CH0_USB0EP1RX) was
 509:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // passed as the ui32ChannelNum parameter, extract just the channel number
 510:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // from this parameter.
 511:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 512:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     ui32ChannelNum &= 0x1f;
 668              		.loc 1 512 0
 669 026c 7B68     		ldr	r3, [r7, #4]
 670 026e 03F01F03 		and	r3, r3, #31
 671 0272 7B60     		str	r3, [r7, #4]
 513:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
 514:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 515:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // Check to see if useburst bit is set for this channel.
 516:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 517:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     if(HWREG(UDMA_USEBURSTSET) & (1 << ui32ChannelNum))
 672              		.loc 1 517 0
 673 0274 1D4B     		ldr	r3, .L58
 674 0276 1B68     		ldr	r3, [r3]
 675 0278 7A68     		ldr	r2, [r7, #4]
 676 027a 0121     		movs	r1, #1
 677 027c 01FA02F2 		lsl	r2, r1, r2
 678 0280 1340     		ands	r3, r3, r2
 679 0282 002B     		cmp	r3, #0
 680 0284 03D0     		beq	.L53
 518:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     {
 519:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****         ui32Attr |= UDMA_ATTR_USEBURST;
 681              		.loc 1 519 0
 682 0286 FB68     		ldr	r3, [r7, #12]
 683 0288 43F00103 		orr	r3, r3, #1
 684 028c FB60     		str	r3, [r7, #12]
 685              	.L53:
 520:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     }
 521:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
 522:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 523:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // Check to see if the alternate control bit is set for this channel.
 524:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 525:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     if(HWREG(UDMA_ALTSET) & (1 << ui32ChannelNum))
 686              		.loc 1 525 0
 687 028e 184B     		ldr	r3, .L58+4
 688 0290 1B68     		ldr	r3, [r3]
 689 0292 7A68     		ldr	r2, [r7, #4]
 690 0294 0121     		movs	r1, #1
 691 0296 01FA02F2 		lsl	r2, r1, r2
 692 029a 1340     		ands	r3, r3, r2
 693 029c 002B     		cmp	r3, #0
 694 029e 03D0     		beq	.L54
 526:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     {
 527:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****         ui32Attr |= UDMA_ATTR_ALTSELECT;
 695              		.loc 1 527 0
 696 02a0 FB68     		ldr	r3, [r7, #12]
 697 02a2 43F00203 		orr	r3, r3, #2
 698 02a6 FB60     		str	r3, [r7, #12]
 699              	.L54:
 528:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     }
 529:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
 530:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 531:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // Check to see if the high priority bit is set for this channel.
 532:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 533:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     if(HWREG(UDMA_PRIOSET) & (1 << ui32ChannelNum))
 700              		.loc 1 533 0
 701 02a8 124B     		ldr	r3, .L58+8
 702 02aa 1B68     		ldr	r3, [r3]
 703 02ac 7A68     		ldr	r2, [r7, #4]
 704 02ae 0121     		movs	r1, #1
 705 02b0 01FA02F2 		lsl	r2, r1, r2
 706 02b4 1340     		ands	r3, r3, r2
 707 02b6 002B     		cmp	r3, #0
 708 02b8 03D0     		beq	.L55
 534:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     {
 535:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****         ui32Attr |= UDMA_ATTR_HIGH_PRIORITY;
 709              		.loc 1 535 0
 710 02ba FB68     		ldr	r3, [r7, #12]
 711 02bc 43F00403 		orr	r3, r3, #4
 712 02c0 FB60     		str	r3, [r7, #12]
 713              	.L55:
 536:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     }
 537:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
 538:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 539:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // Check to see if the request mask bit is set for this channel.
 540:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 541:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     if(HWREG(UDMA_REQMASKSET) & (1 << ui32ChannelNum))
 714              		.loc 1 541 0
 715 02c2 0D4B     		ldr	r3, .L58+12
 716 02c4 1B68     		ldr	r3, [r3]
 717 02c6 7A68     		ldr	r2, [r7, #4]
 718 02c8 0121     		movs	r1, #1
 719 02ca 01FA02F2 		lsl	r2, r1, r2
 720 02ce 1340     		ands	r3, r3, r2
 721 02d0 002B     		cmp	r3, #0
 722 02d2 03D0     		beq	.L56
 542:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     {
 543:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****         ui32Attr |= UDMA_ATTR_REQMASK;
 723              		.loc 1 543 0
 724 02d4 FB68     		ldr	r3, [r7, #12]
 725 02d6 43F00803 		orr	r3, r3, #8
 726 02da FB60     		str	r3, [r7, #12]
 727              	.L56:
 544:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     }
 545:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
 546:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 547:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // Return the configuration flags.
 548:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 549:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     return(ui32Attr);
 728              		.loc 1 549 0
 729 02dc FB68     		ldr	r3, [r7, #12]
 550:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** }
 730              		.loc 1 550 0
 731 02de 1846     		mov	r0, r3
 732 02e0 1437     		adds	r7, r7, #20
 733              		.cfi_def_cfa_offset 4
 734 02e2 BD46     		mov	sp, r7
 735              		.cfi_def_cfa_register 13
 736              		@ sp needed
 737 02e4 5DF8047B 		ldr	r7, [sp], #4
 738              		.cfi_restore 7
 739              		.cfi_def_cfa_offset 0
 740 02e8 7047     		bx	lr
 741              	.L59:
 742 02ea 00BF     		.align	2
 743              	.L58:
 744 02ec 18F00F40 		.word	1074786328
 745 02f0 30F00F40 		.word	1074786352
 746 02f4 38F00F40 		.word	1074786360
 747 02f8 20F00F40 		.word	1074786336
 748              		.cfi_endproc
 749              	.LFE13:
 751              		.align	2
 752              		.global	uDMAChannelControlSet
 753              		.thumb
 754              		.thumb_func
 756              	uDMAChannelControlSet:
 757              	.LFB14:
 551:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
 552:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //*****************************************************************************
 553:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //
 554:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! Sets the control parameters for a uDMA channel control structure
 555:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
 556:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! \param ui32ChannelStructIndex is the logical OR of the uDMA channel number
 557:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! with \b UDMA_PRI_SELECT or \b UDMA_ALT_SELECT.
 558:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! \param ui32Control is logical OR of several control values to set the control
 559:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! parameters for the channel.
 560:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
 561:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! This function is used to set control parameters for a uDMA transfer.  These
 562:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! are typically parameters that are not changed often.
 563:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
 564:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! The \e ui32ChannelStructIndex parameter should be the logical OR of the
 565:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! channel number with one of \b UDMA_PRI_SELECT or \b UDMA_ALT_SELECT to
 566:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! choose whether the primary or alternate data structure is used.
 567:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
 568:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! The \e ui32Control parameter is the logical OR of five values: the data size,
 569:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! the source address increment, the destination address increment, the
 570:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! arbitration size, and the use burst flag.  The choices available for each
 571:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! of these values is described below.
 572:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
 573:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! Choose the data size from one of \b UDMA_SIZE_8, \b UDMA_SIZE_16, or
 574:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! \b UDMA_SIZE_32 to select a data size of 8, 16, or 32 bits.
 575:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
 576:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! Choose the source address increment from one of \b UDMA_SRC_INC_8,
 577:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! \b UDMA_SRC_INC_16, \b UDMA_SRC_INC_32, or \b UDMA_SRC_INC_NONE to select
 578:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! an address increment of 8-bit bytes, 16-bit halfwords, 32-bit words, or
 579:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! to select non-incrementing.
 580:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
 581:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! Choose the destination address increment from one of \b UDMA_DST_INC_8,
 582:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! \b UDMA_DST_INC_16, \b UDMA_DST_INC_32, or \b UDMA_DST_INC_NONE to select
 583:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! an address increment of 8-bit bytes, 16-bit halfwords, 32-bit words, or
 584:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! to select non-incrementing.
 585:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
 586:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! The arbitration size determines how many items are transferred before
 587:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! the uDMA controller re-arbitrates for the bus.  Choose the arbitration size
 588:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! from one of \b UDMA_ARB_1, \b UDMA_ARB_2, \b UDMA_ARB_4, \b UDMA_ARB_8,
 589:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! through \b UDMA_ARB_1024 to select the arbitration size from 1 to 1024
 590:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! items, in powers of 2.
 591:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
 592:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! The value \b UDMA_NEXT_USEBURST is used to force the channel to only
 593:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! respond to burst requests at the tail end of a scatter-gather transfer.
 594:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
 595:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! \note The address increment cannot be smaller than the data size.
 596:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
 597:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! \return None
 598:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //
 599:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //*****************************************************************************
 600:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** void
 601:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** uDMAChannelControlSet(uint32_t ui32ChannelStructIndex,
 602:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****                       uint32_t ui32Control)
 603:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** {
 758              		.loc 1 603 0
 759              		.cfi_startproc
 760              		@ args = 0, pretend = 0, frame = 16
 761              		@ frame_needed = 1, uses_anonymous_args = 0
 762              		@ link register save eliminated.
 763 02fc 80B4     		push	{r7}
 764              		.cfi_def_cfa_offset 4
 765              		.cfi_offset 7, -4
 766 02fe 85B0     		sub	sp, sp, #20
 767              		.cfi_def_cfa_offset 24
 768 0300 00AF     		add	r7, sp, #0
 769              		.cfi_def_cfa_register 7
 770 0302 7860     		str	r0, [r7, #4]
 771 0304 3960     		str	r1, [r7]
 604:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     tDMAControlTable *pCtl;
 605:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
 606:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 607:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // Check the arguments.
 608:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 609:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     ASSERT((ui32ChannelStructIndex & 0xffff) < 64);
 610:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     ASSERT(HWREG(UDMA_CTLBASE) != 0);
 611:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
 612:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 613:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // In case a channel selector macro (like UDMA_CH0_USB0EP1RX) was
 614:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // passed as the ui32ChannelStructIndex parameter, extract just the channel
 615:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // index from this parameter.
 616:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 617:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     ui32ChannelStructIndex &= 0x3f;
 772              		.loc 1 617 0
 773 0306 7B68     		ldr	r3, [r7, #4]
 774 0308 03F03F03 		and	r3, r3, #63
 775 030c 7B60     		str	r3, [r7, #4]
 618:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
 619:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 620:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // Get the base address of the control table.
 621:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 622:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     pCtl = (tDMAControlTable *)HWREG(UDMA_CTLBASE);
 776              		.loc 1 622 0
 777 030e 0B4B     		ldr	r3, .L61
 778 0310 1B68     		ldr	r3, [r3]
 779 0312 FB60     		str	r3, [r7, #12]
 623:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
 624:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 625:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // Get the current control word value and mask off the fields to be
 626:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // changed, then OR in the new settings.
 627:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 628:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     pCtl[ui32ChannelStructIndex].ui32Control =
 780              		.loc 1 628 0
 781 0314 7B68     		ldr	r3, [r7, #4]
 782 0316 1B01     		lsls	r3, r3, #4
 783 0318 FA68     		ldr	r2, [r7, #12]
 784 031a 1A44     		add	r2, r2, r3
 629:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****         ((pCtl[ui32ChannelStructIndex].ui32Control &
 785              		.loc 1 629 0
 786 031c 7B68     		ldr	r3, [r7, #4]
 787 031e 1B01     		lsls	r3, r3, #4
 788 0320 F968     		ldr	r1, [r7, #12]
 789 0322 0B44     		add	r3, r3, r1
 790 0324 9968     		ldr	r1, [r3, #8]
 791 0326 064B     		ldr	r3, .L61+4
 792 0328 0B40     		ands	r3, r3, r1
 630:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****           ~(UDMACHCTL_CHCTL_DSTINC_M |
 631:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****             UDMACHCTL_CHCTL_DSTSIZE_M |
 632:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****             UDMACHCTL_CHCTL_SRCINC_M |
 633:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****             UDMACHCTL_CHCTL_SRCSIZE_M |
 634:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****             UDMACHCTL_CHCTL_ARBSIZE_M |
 635:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****             UDMACHCTL_CHCTL_NXTUSEBURST)) |
 793              		.loc 1 635 0
 794 032a 3968     		ldr	r1, [r7]
 795 032c 0B43     		orrs	r3, r3, r1
 628:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****         ((pCtl[ui32ChannelStructIndex].ui32Control &
 796              		.loc 1 628 0
 797 032e 9360     		str	r3, [r2, #8]
 636:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****          ui32Control);
 637:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** }
 798              		.loc 1 637 0
 799 0330 1437     		adds	r7, r7, #20
 800              		.cfi_def_cfa_offset 4
 801 0332 BD46     		mov	sp, r7
 802              		.cfi_def_cfa_register 13
 803              		@ sp needed
 804 0334 5DF8047B 		ldr	r7, [sp], #4
 805              		.cfi_restore 7
 806              		.cfi_def_cfa_offset 0
 807 0338 7047     		bx	lr
 808              	.L62:
 809 033a 00BF     		.align	2
 810              	.L61:
 811 033c 08F00F40 		.word	1074786312
 812 0340 F73FFC00 		.word	16531447
 813              		.cfi_endproc
 814              	.LFE14:
 816              		.align	2
 817              		.global	uDMAChannelTransferSet
 818              		.thumb
 819              		.thumb_func
 821              	uDMAChannelTransferSet:
 822              	.LFB15:
 638:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
 639:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //*****************************************************************************
 640:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //
 641:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! Sets the transfer parameters for a uDMA channel control structure
 642:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
 643:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! \param ui32ChannelStructIndex is the logical OR of the uDMA channel number
 644:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! with either \b UDMA_PRI_SELECT or \b UDMA_ALT_SELECT.
 645:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! \param ui32Mode is the type of uDMA transfer.
 646:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! \param pvSrcAddr is the source address for the transfer.
 647:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! \param pvDstAddr is the destination address for the transfer.
 648:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! \param ui32TransferSize is the number of data items to transfer.
 649:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
 650:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! This function is used to set the parameters for a uDMA transfer.  These are
 651:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! typically parameters that are changed often.  The function
 652:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! uDMAChannelControlSet() MUST be called at least once for this channel prior
 653:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! to calling this function.
 654:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
 655:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! The \e ui32ChannelStructIndex parameter should be the logical OR of the
 656:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! channel number with one of \b UDMA_PRI_SELECT or \b UDMA_ALT_SELECT to
 657:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! choose whether the primary or alternate data structure is used.
 658:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
 659:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! The \e ui32Mode parameter should be one of the following values:
 660:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
 661:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! - \b UDMA_MODE_STOP stops the uDMA transfer.  The controller sets the mode
 662:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!   to this value at the end of a transfer.
 663:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! - \b UDMA_MODE_BASIC to perform a basic transfer based on request.
 664:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! - \b UDMA_MODE_AUTO to perform a transfer that will always complete once
 665:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!   started even if request is removed.
 666:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! - \b UDMA_MODE_PINGPONG to set up a transfer that switches between the
 667:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!   primary and alternate control structures for the channel.  This allows
 668:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!   use of ping-pong buffering for uDMA transfers.
 669:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! - \b UDMA_MODE_MEM_SCATTER_GATHER to set up a memory scatter-gather
 670:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!   transfer.
 671:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! - \b UDMA_MODE_PER_SCATTER_GATHER to set up a peripheral scatter-gather
 672:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!   transfer.
 673:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
 674:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! The \e pvSrcAddr and \e pvDstAddr parameters are pointers to the first
 675:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! location of the data to be transferred.  These addresses should be aligned
 676:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! according to the item size.  The compiler will take care of this if the
 677:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! pointers are pointing to storage of the appropriate data type.
 678:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
 679:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! The \e ui32TransferSize parameter is the number of data items, not the number
 680:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! of bytes.
 681:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
 682:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! The two scatter/gather modes, memory and peripheral, are actually different
 683:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! depending on whether the primary or alternate control structure is
 684:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! selected.  This function will look for the \b UDMA_PRI_SELECT and
 685:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! \b UDMA_ALT_SELECT flag along with the channel number and will set the
 686:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! scatter/gather mode as appropriate for the primary or alternate control
 687:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! structure.
 688:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
 689:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! The channel must also be enabled using uDMAChannelEnable() after calling
 690:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! this function.  The transfer will not begin until the channel has been set
 691:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! up and enabled.  Note that the channel is automatically disabled after the
 692:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! transfer is completed, meaning that uDMAChannelEnable() must be called
 693:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! again after setting up the next transfer.
 694:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
 695:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! \note Great care must be taken to not modify a channel control structure
 696:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! that is in use or else the results will be unpredictable, including the
 697:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! possibility of undesired data transfers to or from memory or peripherals.
 698:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! For BASIC and AUTO modes, it is safe to make changes when the channel is
 699:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! disabled, or the uDMAChannelModeGet() returns \b UDMA_MODE_STOP.  For
 700:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! PINGPONG or one of the SCATTER_GATHER modes, it is safe to modify the
 701:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! primary or alternate control structure only when the other is being used.
 702:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! The uDMAChannelModeGet() function will return \b UDMA_MODE_STOP when a
 703:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! channel control structure is inactive and safe to modify.
 704:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
 705:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! \return None
 706:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //
 707:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //*****************************************************************************
 708:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** void
 709:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** uDMAChannelTransferSet(uint32_t ui32ChannelStructIndex,
 710:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****                        uint32_t ui32Mode, void *pvSrcAddr, void *pvDstAddr,
 711:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****                        uint32_t ui32TransferSize)
 712:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** {
 823              		.loc 1 712 0
 824              		.cfi_startproc
 825              		@ args = 4, pretend = 0, frame = 32
 826              		@ frame_needed = 1, uses_anonymous_args = 0
 827              		@ link register save eliminated.
 828 0344 80B4     		push	{r7}
 829              		.cfi_def_cfa_offset 4
 830              		.cfi_offset 7, -4
 831 0346 89B0     		sub	sp, sp, #36
 832              		.cfi_def_cfa_offset 40
 833 0348 00AF     		add	r7, sp, #0
 834              		.cfi_def_cfa_register 7
 835 034a F860     		str	r0, [r7, #12]
 836 034c B960     		str	r1, [r7, #8]
 837 034e 7A60     		str	r2, [r7, #4]
 838 0350 3B60     		str	r3, [r7]
 713:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     tDMAControlTable *pControlTable;
 714:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     uint32_t ui32Control;
 715:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     uint32_t ui32Inc;
 716:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     uint32_t ui32BufferBytes;
 717:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
 718:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 719:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // Check the arguments.
 720:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 721:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     ASSERT((ui32ChannelStructIndex & 0xffff) < 64);
 722:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     ASSERT(HWREG(UDMA_CTLBASE) != 0);
 723:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     ASSERT(ui32Mode <= UDMA_MODE_PER_SCATTER_GATHER);
 724:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     ASSERT((uint32_t)pvSrcAddr >= 0x20000000);
 725:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     ASSERT((uint32_t)pvDstAddr >= 0x20000000);
 726:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     ASSERT((ui32TransferSize != 0) && (ui32TransferSize <= 1024));
 727:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
 728:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 729:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // In case a channel selector macro (like UDMA_CH0_USB0EP1RX) was
 730:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // passed as the ui32ChannelStructIndex parameter, extract just the channel
 731:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // index from this parameter.
 732:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 733:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     ui32ChannelStructIndex &= 0x3f;
 839              		.loc 1 733 0
 840 0352 FB68     		ldr	r3, [r7, #12]
 841 0354 03F03F03 		and	r3, r3, #63
 842 0358 FB60     		str	r3, [r7, #12]
 734:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
 735:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 736:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // Get the base address of the control table.
 737:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 738:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     pControlTable = (tDMAControlTable *)HWREG(UDMA_CTLBASE);
 843              		.loc 1 738 0
 844 035a 3A4B     		ldr	r3, .L70
 845 035c 1B68     		ldr	r3, [r3]
 846 035e FB61     		str	r3, [r7, #28]
 739:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
 740:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 741:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // Get the current control word value and mask off the mode and size
 742:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // fields.
 743:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 744:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     ui32Control = (pControlTable[ui32ChannelStructIndex].ui32Control &
 847              		.loc 1 744 0
 848 0360 FB68     		ldr	r3, [r7, #12]
 849 0362 1B01     		lsls	r3, r3, #4
 850 0364 FA69     		ldr	r2, [r7, #28]
 851 0366 1344     		add	r3, r3, r2
 852 0368 9B68     		ldr	r3, [r3, #8]
 853 036a 23F47F53 		bic	r3, r3, #16320
 854 036e 23F03703 		bic	r3, r3, #55
 855 0372 BB61     		str	r3, [r7, #24]
 745:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****                    ~(UDMACHCTL_CHCTL_XFERSIZE_M | UDMACHCTL_CHCTL_XFERMODE_M));
 746:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
 747:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 748:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // Adjust the mode if the alt control structure is selected.
 749:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 750:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     if(ui32ChannelStructIndex & UDMA_ALT_SELECT)
 856              		.loc 1 750 0
 857 0374 FB68     		ldr	r3, [r7, #12]
 858 0376 03F02003 		and	r3, r3, #32
 859 037a 002B     		cmp	r3, #0
 860 037c 09D0     		beq	.L64
 751:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     {
 752:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****         if((ui32Mode == UDMA_MODE_MEM_SCATTER_GATHER) ||
 861              		.loc 1 752 0
 862 037e BB68     		ldr	r3, [r7, #8]
 863 0380 042B     		cmp	r3, #4
 864 0382 02D0     		beq	.L65
 865              		.loc 1 752 0 is_stmt 0 discriminator 1
 866 0384 BB68     		ldr	r3, [r7, #8]
 867 0386 062B     		cmp	r3, #6
 868 0388 03D1     		bne	.L64
 869              	.L65:
 753:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****                 (ui32Mode == UDMA_MODE_PER_SCATTER_GATHER))
 754:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****         {
 755:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****             ui32Mode |= UDMA_MODE_ALT_SELECT;
 870              		.loc 1 755 0 is_stmt 1
 871 038a BB68     		ldr	r3, [r7, #8]
 872 038c 43F00103 		orr	r3, r3, #1
 873 0390 BB60     		str	r3, [r7, #8]
 874              	.L64:
 756:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****         }
 757:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     }
 758:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
 759:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 760:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // Set the transfer size and mode in the control word (but don't write the
 761:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // control word yet as it could kick off a transfer).
 762:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 763:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     ui32Control |= ui32Mode | ((ui32TransferSize - 1) << 4);
 875              		.loc 1 763 0
 876 0392 BB6A     		ldr	r3, [r7, #40]
 877 0394 013B     		subs	r3, r3, #1
 878 0396 1A01     		lsls	r2, r3, #4
 879 0398 BB68     		ldr	r3, [r7, #8]
 880 039a 1343     		orrs	r3, r3, r2
 881 039c BA69     		ldr	r2, [r7, #24]
 882 039e 1343     		orrs	r3, r3, r2
 883 03a0 BB61     		str	r3, [r7, #24]
 764:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
 765:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 766:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // Get the address increment value for the source, from the control word.
 767:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 768:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     ui32Inc = (ui32Control & UDMACHCTL_CHCTL_SRCINC_M);
 884              		.loc 1 768 0
 885 03a2 BB69     		ldr	r3, [r7, #24]
 886 03a4 03F04063 		and	r3, r3, #201326592
 887 03a8 7B61     		str	r3, [r7, #20]
 769:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
 770:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 771:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // Compute the ending source address of the transfer.  If the source
 772:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // increment is set to none, then the ending address is the same as the
 773:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // beginning.
 774:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 775:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     if(ui32Inc != UDMA_SRC_INC_NONE)
 888              		.loc 1 775 0
 889 03aa 7B69     		ldr	r3, [r7, #20]
 890 03ac B3F1406F 		cmp	r3, #201326592
 891 03b0 0CD0     		beq	.L66
 776:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     {
 777:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****         ui32Inc = ui32Inc >> 26;
 892              		.loc 1 777 0
 893 03b2 7B69     		ldr	r3, [r7, #20]
 894 03b4 9B0E     		lsrs	r3, r3, #26
 895 03b6 7B61     		str	r3, [r7, #20]
 778:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****         ui32BufferBytes = ui32TransferSize << ui32Inc;
 896              		.loc 1 778 0
 897 03b8 7B69     		ldr	r3, [r7, #20]
 898 03ba BA6A     		ldr	r2, [r7, #40]
 899 03bc 02FA03F3 		lsl	r3, r2, r3
 900 03c0 3B61     		str	r3, [r7, #16]
 779:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****         pvSrcAddr = (void *)((uint32_t)pvSrcAddr + ui32BufferBytes - 1);
 901              		.loc 1 779 0
 902 03c2 7A68     		ldr	r2, [r7, #4]
 903 03c4 3B69     		ldr	r3, [r7, #16]
 904 03c6 1344     		add	r3, r3, r2
 905 03c8 013B     		subs	r3, r3, #1
 906 03ca 7B60     		str	r3, [r7, #4]
 907              	.L66:
 780:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     }
 781:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
 782:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 783:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // Load the source ending address into the control block.
 784:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 785:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     pControlTable[ui32ChannelStructIndex].pvSrcEndAddr = pvSrcAddr;
 908              		.loc 1 785 0
 909 03cc FB68     		ldr	r3, [r7, #12]
 910 03ce 1B01     		lsls	r3, r3, #4
 911 03d0 FA69     		ldr	r2, [r7, #28]
 912 03d2 1344     		add	r3, r3, r2
 913 03d4 7A68     		ldr	r2, [r7, #4]
 914 03d6 1A60     		str	r2, [r3]
 786:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
 787:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 788:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // Get the address increment value for the destination, from the control
 789:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // word.
 790:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 791:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     ui32Inc = ui32Control & UDMACHCTL_CHCTL_DSTINC_M;
 915              		.loc 1 791 0
 916 03d8 BB69     		ldr	r3, [r7, #24]
 917 03da 03F04043 		and	r3, r3, #-1073741824
 918 03de 7B61     		str	r3, [r7, #20]
 792:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
 793:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 794:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // Compute the ending destination address of the transfer.  If the
 795:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // destination increment is set to none, then the ending address is the
 796:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // same as the beginning.
 797:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 798:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     if(ui32Inc != UDMA_DST_INC_NONE)
 919              		.loc 1 798 0
 920 03e0 7B69     		ldr	r3, [r7, #20]
 921 03e2 B3F1404F 		cmp	r3, #-1073741824
 922 03e6 1BD0     		beq	.L67
 799:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     {
 800:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****         //
 801:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****         // There is a special case if this is setting up a scatter-gather
 802:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****         // transfer.  The destination pointer needs to point to the end of
 803:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****         // the alternate structure for this channel instead of calculating
 804:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****         // the end of the buffer in the normal way.
 805:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****         //
 806:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****         if((ui32Mode == UDMA_MODE_MEM_SCATTER_GATHER) ||
 923              		.loc 1 806 0
 924 03e8 BB68     		ldr	r3, [r7, #8]
 925 03ea 042B     		cmp	r3, #4
 926 03ec 02D0     		beq	.L68
 927              		.loc 1 806 0 is_stmt 0 discriminator 1
 928 03ee BB68     		ldr	r3, [r7, #8]
 929 03f0 062B     		cmp	r3, #6
 930 03f2 08D1     		bne	.L69
 931              	.L68:
 807:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****                 (ui32Mode == UDMA_MODE_PER_SCATTER_GATHER))
 808:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****         {
 809:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****             pvDstAddr =
 810:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****                 (void *)&pControlTable[ui32ChannelStructIndex |
 932              		.loc 1 810 0 is_stmt 1
 933 03f4 FB68     		ldr	r3, [r7, #12]
 934 03f6 43F02003 		orr	r3, r3, #32
 935 03fa 1B01     		lsls	r3, r3, #4
 936 03fc FA69     		ldr	r2, [r7, #28]
 937 03fe 1344     		add	r3, r3, r2
 809:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****                 (void *)&pControlTable[ui32ChannelStructIndex |
 938              		.loc 1 809 0
 939 0400 0C33     		adds	r3, r3, #12
 940 0402 3B60     		str	r3, [r7]
 941 0404 0CE0     		b	.L67
 942              	.L69:
 811:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****                                        UDMA_ALT_SELECT].ui32Spare;
 812:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****         }
 813:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****         //
 814:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****         // Not a scatter-gather transfer, calculate end pointer normally.
 815:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****         //
 816:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****         else
 817:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****         {
 818:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****             ui32Inc = ui32Inc >> 30;
 943              		.loc 1 818 0
 944 0406 7B69     		ldr	r3, [r7, #20]
 945 0408 9B0F     		lsrs	r3, r3, #30
 946 040a 7B61     		str	r3, [r7, #20]
 819:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****             ui32BufferBytes = ui32TransferSize << ui32Inc;
 947              		.loc 1 819 0
 948 040c 7B69     		ldr	r3, [r7, #20]
 949 040e BA6A     		ldr	r2, [r7, #40]
 950 0410 02FA03F3 		lsl	r3, r2, r3
 951 0414 3B61     		str	r3, [r7, #16]
 820:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****             pvDstAddr = (void *)((uint32_t)pvDstAddr + ui32BufferBytes - 1);
 952              		.loc 1 820 0
 953 0416 3A68     		ldr	r2, [r7]
 954 0418 3B69     		ldr	r3, [r7, #16]
 955 041a 1344     		add	r3, r3, r2
 956 041c 013B     		subs	r3, r3, #1
 957 041e 3B60     		str	r3, [r7]
 958              	.L67:
 821:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****         }
 822:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     }
 823:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
 824:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 825:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // Load the destination ending address into the control block.
 826:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 827:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     pControlTable[ui32ChannelStructIndex].pvDstEndAddr = pvDstAddr;
 959              		.loc 1 827 0
 960 0420 FB68     		ldr	r3, [r7, #12]
 961 0422 1B01     		lsls	r3, r3, #4
 962 0424 FA69     		ldr	r2, [r7, #28]
 963 0426 1344     		add	r3, r3, r2
 964 0428 3A68     		ldr	r2, [r7]
 965 042a 5A60     		str	r2, [r3, #4]
 828:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
 829:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 830:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // Write the new control word value.
 831:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 832:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     pControlTable[ui32ChannelStructIndex].ui32Control = ui32Control;
 966              		.loc 1 832 0
 967 042c FB68     		ldr	r3, [r7, #12]
 968 042e 1B01     		lsls	r3, r3, #4
 969 0430 FA69     		ldr	r2, [r7, #28]
 970 0432 1344     		add	r3, r3, r2
 971 0434 BA69     		ldr	r2, [r7, #24]
 972 0436 9A60     		str	r2, [r3, #8]
 833:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** }
 973              		.loc 1 833 0
 974 0438 2437     		adds	r7, r7, #36
 975              		.cfi_def_cfa_offset 4
 976 043a BD46     		mov	sp, r7
 977              		.cfi_def_cfa_register 13
 978              		@ sp needed
 979 043c 5DF8047B 		ldr	r7, [sp], #4
 980              		.cfi_restore 7
 981              		.cfi_def_cfa_offset 0
 982 0440 7047     		bx	lr
 983              	.L71:
 984 0442 00BF     		.align	2
 985              	.L70:
 986 0444 08F00F40 		.word	1074786312
 987              		.cfi_endproc
 988              	.LFE15:
 990              		.align	2
 991              		.global	uDMAChannelScatterGatherSet
 992              		.thumb
 993              		.thumb_func
 995              	uDMAChannelScatterGatherSet:
 996              	.LFB16:
 834:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
 835:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //*****************************************************************************
 836:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //
 837:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! Configures a uDMA channel for scatter-gather mode
 838:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
 839:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! \param ui32ChannelNum is the uDMA channel number.
 840:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! \param ui32TaskCount is the number of scatter-gather tasks to execute.
 841:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! \param pvTaskList is a pointer to the beginning of the scatter-gather
 842:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! task list.
 843:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! \param ui32IsPeriphSG is a flag to indicate it is a peripheral scatter-gather
 844:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! transfer (else it will be memory scatter-gather transfer)
 845:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
 846:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! This function is used to configure a channel for scatter-gather mode.
 847:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! The caller must have already set up a task list, and pass a pointer to
 848:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! the start of the task list as the \e pvTaskList parameter.  The
 849:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! \e ui32TaskCount parameter is the count of tasks in the task list, not the
 850:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! size of the task list.  The flag \e bIsPeriphSG should be used to indicate
 851:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! if the scatter-gather should be configured for a peripheral or memory
 852:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! scatter-gather operation.
 853:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
 854:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! \sa uDMATaskStructEntry
 855:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
 856:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! \return None
 857:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //
 858:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //*****************************************************************************
 859:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** void
 860:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** uDMAChannelScatterGatherSet(uint32_t ui32ChannelNum,
 861:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****                             uint32_t ui32TaskCount, void *pvTaskList,
 862:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****                             uint32_t ui32IsPeriphSG)
 863:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** {
 997              		.loc 1 863 0
 998              		.cfi_startproc
 999              		@ args = 0, pretend = 0, frame = 24
 1000              		@ frame_needed = 1, uses_anonymous_args = 0
 1001              		@ link register save eliminated.
 1002 0448 80B4     		push	{r7}
 1003              		.cfi_def_cfa_offset 4
 1004              		.cfi_offset 7, -4
 1005 044a 87B0     		sub	sp, sp, #28
 1006              		.cfi_def_cfa_offset 32
 1007 044c 00AF     		add	r7, sp, #0
 1008              		.cfi_def_cfa_register 7
 1009 044e F860     		str	r0, [r7, #12]
 1010 0450 B960     		str	r1, [r7, #8]
 1011 0452 7A60     		str	r2, [r7, #4]
 1012 0454 3B60     		str	r3, [r7]
 864:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     tDMAControlTable *pControlTable;
 865:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     tDMAControlTable *pTaskTable;
 866:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
 867:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 868:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // Check the parameters
 869:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 870:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     ASSERT((ui32ChannelNum & 0xffff) < 32);
 871:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     ASSERT(HWREG(UDMA_CTLBASE) != 0);
 872:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     ASSERT(pvTaskList != 0);
 873:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     ASSERT(ui32TaskCount <= 1024);
 874:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     ASSERT(ui32TaskCount != 0);
 875:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
 876:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 877:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // In case a channel selector macro (like UDMA_CH0_USB0EP1RX) was
 878:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // passed as the ui32ChannelNum parameter, extract just the channel number
 879:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // from this parameter.
 880:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 881:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     ui32ChannelNum &= 0x1f;
 1013              		.loc 1 881 0
 1014 0456 FB68     		ldr	r3, [r7, #12]
 1015 0458 03F01F03 		and	r3, r3, #31
 1016 045c FB60     		str	r3, [r7, #12]
 882:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
 883:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 884:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // Get the base address of the control table.
 885:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 886:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     pControlTable = (tDMAControlTable *)HWREG(UDMA_CTLBASE);
 1017              		.loc 1 886 0
 1018 045e 1B4B     		ldr	r3, .L75
 1019 0460 1B68     		ldr	r3, [r3]
 1020 0462 7B61     		str	r3, [r7, #20]
 887:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
 888:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 889:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // Get a handy pointer to the task list
 890:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 891:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     pTaskTable = (tDMAControlTable *)pvTaskList;
 1021              		.loc 1 891 0
 1022 0464 7B68     		ldr	r3, [r7, #4]
 1023 0466 3B61     		str	r3, [r7, #16]
 892:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
 893:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 894:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // Compute the ending address for the source pointer.  This will be the
 895:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // last element of the last task in the task table
 896:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 897:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     pControlTable[ui32ChannelNum].pvSrcEndAddr =
 1024              		.loc 1 897 0
 1025 0468 FB68     		ldr	r3, [r7, #12]
 1026 046a 1B01     		lsls	r3, r3, #4
 1027 046c 7A69     		ldr	r2, [r7, #20]
 1028 046e 1A44     		add	r2, r2, r3
 898:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****         &pTaskTable[ui32TaskCount - 1].ui32Spare;
 1029              		.loc 1 898 0
 1030 0470 BB68     		ldr	r3, [r7, #8]
 1031 0472 03F18053 		add	r3, r3, #268435456
 1032 0476 013B     		subs	r3, r3, #1
 1033 0478 1B01     		lsls	r3, r3, #4
 1034 047a 3969     		ldr	r1, [r7, #16]
 1035 047c 0B44     		add	r3, r3, r1
 1036 047e 0C33     		adds	r3, r3, #12
 897:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****         &pTaskTable[ui32TaskCount - 1].ui32Spare;
 1037              		.loc 1 897 0
 1038 0480 1360     		str	r3, [r2]
 899:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
 900:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 901:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // Compute the ending address for the destination pointer.  This will be
 902:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // the end of the alternate structure for this channel.
 903:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 904:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     pControlTable[ui32ChannelNum].pvDstEndAddr =
 1039              		.loc 1 904 0
 1040 0482 FB68     		ldr	r3, [r7, #12]
 1041 0484 1B01     		lsls	r3, r3, #4
 1042 0486 7A69     		ldr	r2, [r7, #20]
 1043 0488 1344     		add	r3, r3, r2
 905:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****         &pControlTable[ui32ChannelNum | UDMA_ALT_SELECT].ui32Spare;
 1044              		.loc 1 905 0
 1045 048a FA68     		ldr	r2, [r7, #12]
 1046 048c 42F02002 		orr	r2, r2, #32
 1047 0490 1201     		lsls	r2, r2, #4
 1048 0492 7969     		ldr	r1, [r7, #20]
 1049 0494 0A44     		add	r2, r2, r1
 1050 0496 0C32     		adds	r2, r2, #12
 904:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****         &pControlTable[ui32ChannelNum | UDMA_ALT_SELECT].ui32Spare;
 1051              		.loc 1 904 0
 1052 0498 5A60     		str	r2, [r3, #4]
 906:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
 907:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 908:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // Compute the control word.  Most configurable items are fixed for
 909:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // scatter-gather.  Item and increment sizes are all 32-bit and arb
 910:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // size must be 4.  The count is the number of items in the task list
 911:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // times 4 (4 words per task).
 912:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 913:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     pControlTable[ui32ChannelNum].ui32Control =
 1053              		.loc 1 913 0
 1054 049a FB68     		ldr	r3, [r7, #12]
 1055 049c 1B01     		lsls	r3, r3, #4
 1056 049e 7A69     		ldr	r2, [r7, #20]
 1057 04a0 1A44     		add	r2, r2, r3
 914:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****         (UDMA_CHCTL_DSTINC_32 | UDMA_CHCTL_DSTSIZE_32 |
 915:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****          UDMA_CHCTL_SRCINC_32 | UDMA_CHCTL_SRCSIZE_32 |
 916:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****          UDMA_CHCTL_ARBSIZE_4 |
 917:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****          (((ui32TaskCount * 4) - 1) << UDMACHCTL_CHCTL_XFERSIZE_S) |
 1058              		.loc 1 917 0
 1059 04a2 BB68     		ldr	r3, [r7, #8]
 1060 04a4 9B00     		lsls	r3, r3, #2
 1061 04a6 013B     		subs	r3, r3, #1
 1062 04a8 1901     		lsls	r1, r3, #4
 1063 04aa 3B68     		ldr	r3, [r7]
 1064 04ac 002B     		cmp	r3, #0
 1065 04ae 01D0     		beq	.L73
 1066              		.loc 1 917 0 is_stmt 0 discriminator 1
 1067 04b0 0623     		movs	r3, #6
 1068 04b2 00E0     		b	.L74
 1069              	.L73:
 1070              		.loc 1 917 0 discriminator 2
 1071 04b4 0423     		movs	r3, #4
 1072              	.L74:
 1073              		.loc 1 917 0 discriminator 4
 1074 04b6 0B43     		orrs	r3, r3, r1
 1075 04b8 43F02A43 		orr	r3, r3, #-1442840576
 1076 04bc 43F40043 		orr	r3, r3, #32768
 913:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****         (UDMA_CHCTL_DSTINC_32 | UDMA_CHCTL_DSTSIZE_32 |
 1077              		.loc 1 913 0 is_stmt 1 discriminator 4
 1078 04c0 9360     		str	r3, [r2, #8]
 918:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****          (ui32IsPeriphSG ? UDMA_CHCTL_XFERMODE_PER_SG :
 919:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****           UDMA_CHCTL_XFERMODE_MEM_SG));
 920:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** }
 1079              		.loc 1 920 0 discriminator 4
 1080 04c2 1C37     		adds	r7, r7, #28
 1081              		.cfi_def_cfa_offset 4
 1082 04c4 BD46     		mov	sp, r7
 1083              		.cfi_def_cfa_register 13
 1084              		@ sp needed
 1085 04c6 5DF8047B 		ldr	r7, [sp], #4
 1086              		.cfi_restore 7
 1087              		.cfi_def_cfa_offset 0
 1088 04ca 7047     		bx	lr
 1089              	.L76:
 1090              		.align	2
 1091              	.L75:
 1092 04cc 08F00F40 		.word	1074786312
 1093              		.cfi_endproc
 1094              	.LFE16:
 1096              		.align	2
 1097              		.global	uDMAChannelSizeGet
 1098              		.thumb
 1099              		.thumb_func
 1101              	uDMAChannelSizeGet:
 1102              	.LFB17:
 921:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
 922:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //*****************************************************************************
 923:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //
 924:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! Gets the current transfer size for a uDMA channel control structure
 925:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
 926:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! \param ui32ChannelStructIndex is the logical OR of the uDMA channel number
 927:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! with either \b UDMA_PRI_SELECT or \b UDMA_ALT_SELECT.
 928:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
 929:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! This function is used to get the uDMA transfer size for a channel.  The
 930:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! transfer size is the number of items to transfer, where the size of an item
 931:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! might be 8, 16, or 32 bits.  If a partial transfer has already occurred,
 932:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! then the number of remaining items will be returned.  If the transfer is
 933:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! complete, then 0 will be returned.
 934:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
 935:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! \return Returns the number of items remaining to transfer.
 936:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //
 937:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //*****************************************************************************
 938:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** uint32_t
 939:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** uDMAChannelSizeGet(uint32_t ui32ChannelStructIndex)
 940:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** {
 1103              		.loc 1 940 0
 1104              		.cfi_startproc
 1105              		@ args = 0, pretend = 0, frame = 16
 1106              		@ frame_needed = 1, uses_anonymous_args = 0
 1107              		@ link register save eliminated.
 1108 04d0 80B4     		push	{r7}
 1109              		.cfi_def_cfa_offset 4
 1110              		.cfi_offset 7, -4
 1111 04d2 85B0     		sub	sp, sp, #20
 1112              		.cfi_def_cfa_offset 24
 1113 04d4 00AF     		add	r7, sp, #0
 1114              		.cfi_def_cfa_register 7
 1115 04d6 7860     		str	r0, [r7, #4]
 941:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     tDMAControlTable *pControlTable;
 942:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     uint32_t ui32Control;
 943:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
 944:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 945:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // Check the arguments.
 946:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 947:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     ASSERT((ui32ChannelStructIndex & 0xffff) < 64);
 948:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     ASSERT(HWREG(UDMA_CTLBASE) != 0);
 949:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
 950:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 951:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // In case a channel selector macro (like UDMA_CH0_USB0EP1RX) was
 952:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // passed as the ui32ChannelStructIndex parameter, extract just the channel
 953:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // index from this parameter.
 954:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 955:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     ui32ChannelStructIndex &= 0x3f;
 1116              		.loc 1 955 0
 1117 04d8 7B68     		ldr	r3, [r7, #4]
 1118 04da 03F03F03 		and	r3, r3, #63
 1119 04de 7B60     		str	r3, [r7, #4]
 956:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
 957:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 958:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // Get the base address of the control table.
 959:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 960:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     pControlTable = (tDMAControlTable *)HWREG(UDMA_CTLBASE);
 1120              		.loc 1 960 0
 1121 04e0 0C4B     		ldr	r3, .L80
 1122 04e2 1B68     		ldr	r3, [r3]
 1123 04e4 FB60     		str	r3, [r7, #12]
 961:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
 962:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 963:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // Get the current control word value and mask off all but the size field
 964:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // and the mode field.
 965:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 966:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     ui32Control = (pControlTable[ui32ChannelStructIndex].ui32Control &
 1124              		.loc 1 966 0
 1125 04e6 7B68     		ldr	r3, [r7, #4]
 1126 04e8 1B01     		lsls	r3, r3, #4
 1127 04ea FA68     		ldr	r2, [r7, #12]
 1128 04ec 1344     		add	r3, r3, r2
 1129 04ee 9A68     		ldr	r2, [r3, #8]
 1130 04f0 43F6F773 		movw	r3, #16375
 1131 04f4 1340     		ands	r3, r3, r2
 1132 04f6 BB60     		str	r3, [r7, #8]
 967:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****                    (UDMACHCTL_CHCTL_XFERSIZE_M | UDMACHCTL_CHCTL_XFERMODE_M));
 968:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
 969:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 970:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // If the size field and mode field are 0 then the transfer is finished
 971:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // and there are no more items to transfer
 972:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 973:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     if(ui32Control == 0)
 1133              		.loc 1 973 0
 1134 04f8 BB68     		ldr	r3, [r7, #8]
 1135 04fa 002B     		cmp	r3, #0
 1136 04fc 01D1     		bne	.L78
 974:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     {
 975:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****         return(0);
 1137              		.loc 1 975 0
 1138 04fe 0023     		movs	r3, #0
 1139 0500 02E0     		b	.L79
 1140              	.L78:
 976:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     }
 977:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
 978:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 979:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // Otherwise, if either the size field or more field is non-zero, then
 980:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // not all the items have been transferred.
 981:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
 982:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     else
 983:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     {
 984:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****         //
 985:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****         // Shift the size field and add one, then return to user.
 986:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****         //
 987:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****         return((ui32Control >> 4) + 1);
 1141              		.loc 1 987 0
 1142 0502 BB68     		ldr	r3, [r7, #8]
 1143 0504 1B09     		lsrs	r3, r3, #4
 1144 0506 0133     		adds	r3, r3, #1
 1145              	.L79:
 988:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     }
 989:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** }
 1146              		.loc 1 989 0
 1147 0508 1846     		mov	r0, r3
 1148 050a 1437     		adds	r7, r7, #20
 1149              		.cfi_def_cfa_offset 4
 1150 050c BD46     		mov	sp, r7
 1151              		.cfi_def_cfa_register 13
 1152              		@ sp needed
 1153 050e 5DF8047B 		ldr	r7, [sp], #4
 1154              		.cfi_restore 7
 1155              		.cfi_def_cfa_offset 0
 1156 0512 7047     		bx	lr
 1157              	.L81:
 1158              		.align	2
 1159              	.L80:
 1160 0514 08F00F40 		.word	1074786312
 1161              		.cfi_endproc
 1162              	.LFE17:
 1164              		.align	2
 1165              		.global	uDMAChannelModeGet
 1166              		.thumb
 1167              		.thumb_func
 1169              	uDMAChannelModeGet:
 1170              	.LFB18:
 990:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
 991:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //*****************************************************************************
 992:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //
 993:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! Gets the transfer mode for a uDMA channel control structure
 994:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
 995:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! \param ui32ChannelStructIndex is the logical OR of the uDMA channel number
 996:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! with either \b UDMA_PRI_SELECT or \b UDMA_ALT_SELECT.
 997:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
 998:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! This function is used to get the transfer mode for the uDMA channel.  It
 999:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! can be used to query the status of a transfer on a channel.  When the
1000:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! transfer is complete the mode will be \b UDMA_MODE_STOP.
1001:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
1002:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! \return Returns the transfer mode of the specified channel and control
1003:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! structure, which will be one of the following values: \b UDMA_MODE_STOP,
1004:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! \b UDMA_MODE_BASIC, \b UDMA_MODE_AUTO, \b UDMA_MODE_PINGPONG,
1005:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! \b UDMA_MODE_MEM_SCATTER_GATHER, or \b UDMA_MODE_PER_SCATTER_GATHER.
1006:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //
1007:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //*****************************************************************************
1008:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** uint32_t
1009:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** uDMAChannelModeGet(uint32_t ui32ChannelStructIndex)
1010:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** {
 1171              		.loc 1 1010 0
 1172              		.cfi_startproc
 1173              		@ args = 0, pretend = 0, frame = 16
 1174              		@ frame_needed = 1, uses_anonymous_args = 0
 1175              		@ link register save eliminated.
 1176 0518 80B4     		push	{r7}
 1177              		.cfi_def_cfa_offset 4
 1178              		.cfi_offset 7, -4
 1179 051a 85B0     		sub	sp, sp, #20
 1180              		.cfi_def_cfa_offset 24
 1181 051c 00AF     		add	r7, sp, #0
 1182              		.cfi_def_cfa_register 7
 1183 051e 7860     		str	r0, [r7, #4]
1011:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     tDMAControlTable *pControlTable;
1012:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     uint32_t ui32Control;
1013:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
1014:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
1015:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // Check the arguments.
1016:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
1017:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     ASSERT((ui32ChannelStructIndex & 0xffff) < 64);
1018:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     ASSERT(HWREG(UDMA_CTLBASE) != 0);
1019:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
1020:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
1021:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // In case a channel selector macro (like UDMA_CH0_USB0EP1RX) was
1022:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // passed as the ui32ChannelStructIndex parameter, extract just the channel
1023:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // index from this parameter.
1024:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
1025:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     ui32ChannelStructIndex &= 0x3f;
 1184              		.loc 1 1025 0
 1185 0520 7B68     		ldr	r3, [r7, #4]
 1186 0522 03F03F03 		and	r3, r3, #63
 1187 0526 7B60     		str	r3, [r7, #4]
1026:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
1027:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
1028:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // Get the base address of the control table.
1029:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
1030:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     pControlTable = (tDMAControlTable *)HWREG(UDMA_CTLBASE);
 1188              		.loc 1 1030 0
 1189 0528 0F4B     		ldr	r3, .L86
 1190 052a 1B68     		ldr	r3, [r3]
 1191 052c BB60     		str	r3, [r7, #8]
1031:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
1032:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
1033:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // Get the current control word value and mask off all but the mode field.
1034:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
1035:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     ui32Control = (pControlTable[ui32ChannelStructIndex].ui32Control &
 1192              		.loc 1 1035 0
 1193 052e 7B68     		ldr	r3, [r7, #4]
 1194 0530 1B01     		lsls	r3, r3, #4
 1195 0532 BA68     		ldr	r2, [r7, #8]
 1196 0534 1344     		add	r3, r3, r2
 1197 0536 9B68     		ldr	r3, [r3, #8]
 1198 0538 03F00703 		and	r3, r3, #7
 1199 053c FB60     		str	r3, [r7, #12]
1036:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****                    UDMACHCTL_CHCTL_XFERMODE_M);
1037:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
1038:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
1039:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // Check if scatter/gather mode, and if so, mask off the alt bit.
1040:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
1041:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     if(((ui32Control & ~UDMA_MODE_ALT_SELECT) == UDMA_MODE_MEM_SCATTER_GATHER) ||
 1200              		.loc 1 1041 0
 1201 053e FB68     		ldr	r3, [r7, #12]
 1202 0540 23F00103 		bic	r3, r3, #1
 1203 0544 042B     		cmp	r3, #4
 1204 0546 04D0     		beq	.L83
1042:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****             ((ui32Control & ~UDMA_MODE_ALT_SELECT) == UDMA_MODE_PER_SCATTER_GATHER))
 1205              		.loc 1 1042 0 discriminator 1
 1206 0548 FB68     		ldr	r3, [r7, #12]
 1207 054a 23F00103 		bic	r3, r3, #1
1041:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****             ((ui32Control & ~UDMA_MODE_ALT_SELECT) == UDMA_MODE_PER_SCATTER_GATHER))
 1208              		.loc 1 1041 0 discriminator 1
 1209 054e 062B     		cmp	r3, #6
 1210 0550 03D1     		bne	.L84
 1211              	.L83:
1043:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     {
1044:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****         ui32Control &= ~UDMA_MODE_ALT_SELECT;
 1212              		.loc 1 1044 0
 1213 0552 FB68     		ldr	r3, [r7, #12]
 1214 0554 23F00103 		bic	r3, r3, #1
 1215 0558 FB60     		str	r3, [r7, #12]
 1216              	.L84:
1045:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     }
1046:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
1047:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
1048:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // Return the mode to the caller.
1049:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
1050:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     return(ui32Control);
 1217              		.loc 1 1050 0
 1218 055a FB68     		ldr	r3, [r7, #12]
1051:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** }
 1219              		.loc 1 1051 0
 1220 055c 1846     		mov	r0, r3
 1221 055e 1437     		adds	r7, r7, #20
 1222              		.cfi_def_cfa_offset 4
 1223 0560 BD46     		mov	sp, r7
 1224              		.cfi_def_cfa_register 13
 1225              		@ sp needed
 1226 0562 5DF8047B 		ldr	r7, [sp], #4
 1227              		.cfi_restore 7
 1228              		.cfi_def_cfa_offset 0
 1229 0566 7047     		bx	lr
 1230              	.L87:
 1231              		.align	2
 1232              	.L86:
 1233 0568 08F00F40 		.word	1074786312
 1234              		.cfi_endproc
 1235              	.LFE18:
 1237              		.align	2
 1238              		.global	uDMAIntRegister
 1239              		.thumb
 1240              		.thumb_func
 1242              	uDMAIntRegister:
 1243              	.LFB19:
1052:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
1053:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
1054:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //*****************************************************************************
1055:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //
1056:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! Registers an interrupt handler for the uDMA controller
1057:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
1058:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! \param ui32IntChannel identifies which uDMA interrupt is to be registered.
1059:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! \param pfnHandler is a pointer to the function to be called when the
1060:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! interrupt is activated.
1061:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
1062:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! This sets and enables the handler to be called when the uDMA controller
1063:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! generates an interrupt.  The \e ui32IntChannel parameter should be one of the
1064:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! following:
1065:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
1066:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! - \b UDMA_INT_SW to register an interrupt handler to process interrupts
1067:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!   from the uDMA software channel (UDMA_CH30_SW)
1068:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! - \b UDMA_INT_ERR to register an interrupt handler to process uDMA error
1069:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!   interrupts
1070:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
1071:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! \sa IntRegister() for important information about registering interrupt
1072:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! handlers.
1073:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
1074:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! \note The interrupt handler for uDMA is for transfer completion when the
1075:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! channel UDMA_CH30W is used, and for error interrupts.  The
1076:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! interrupts for each peripheral channel are handled through the individual
1077:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! peripheral interrupt handlers.
1078:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
1079:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! \return None
1080:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //
1081:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //*****************************************************************************
1082:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** void
1083:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** uDMAIntRegister(uint32_t ui32IntChannel, void (*pfnHandler)(void))
1084:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** {
 1244              		.loc 1 1084 0
 1245              		.cfi_startproc
 1246              		@ args = 0, pretend = 0, frame = 8
 1247              		@ frame_needed = 1, uses_anonymous_args = 0
 1248 056c 80B5     		push	{r7, lr}
 1249              		.cfi_def_cfa_offset 8
 1250              		.cfi_offset 7, -8
 1251              		.cfi_offset 14, -4
 1252 056e 82B0     		sub	sp, sp, #8
 1253              		.cfi_def_cfa_offset 16
 1254 0570 00AF     		add	r7, sp, #0
 1255              		.cfi_def_cfa_register 7
 1256 0572 7860     		str	r0, [r7, #4]
 1257 0574 3960     		str	r1, [r7]
1085:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
1086:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // Check the arguments.
1087:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
1088:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     ASSERT(pfnHandler);
1089:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     ASSERT((ui32IntChannel == UDMA_INT_SW) || (ui32IntChannel == UDMA_INT_ERR));
1090:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
1091:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
1092:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // Register the interrupt handler.
1093:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
1094:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     IntRegister(ui32IntChannel, pfnHandler);
 1258              		.loc 1 1094 0
 1259 0576 7868     		ldr	r0, [r7, #4]
 1260 0578 3968     		ldr	r1, [r7]
 1261 057a FFF7FEFF 		bl	IntRegister
1095:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
1096:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
1097:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // Enable the memory management fault.
1098:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
1099:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     IntEnable(ui32IntChannel);
 1262              		.loc 1 1099 0
 1263 057e 7868     		ldr	r0, [r7, #4]
 1264 0580 FFF7FEFF 		bl	IntEnable
1100:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** }
 1265              		.loc 1 1100 0
 1266 0584 0837     		adds	r7, r7, #8
 1267              		.cfi_def_cfa_offset 8
 1268 0586 BD46     		mov	sp, r7
 1269              		.cfi_def_cfa_register 13
 1270              		@ sp needed
 1271 0588 80BD     		pop	{r7, pc}
 1272              		.cfi_endproc
 1273              	.LFE19:
 1275 058a 00BF     		.align	2
 1276              		.global	uDMAIntUnregister
 1277              		.thumb
 1278              		.thumb_func
 1280              	uDMAIntUnregister:
 1281              	.LFB20:
1101:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
1102:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //*****************************************************************************
1103:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //
1104:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! Unregisters an interrupt handler for the uDMA controller
1105:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
1106:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! \param ui32IntChannel identifies which uDMA interrupt to unregister.
1107:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
1108:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! This function will disable and clear the handler to be called for the
1109:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! specified uDMA interrupt.  The \e ui32IntChannel parameter should be one of
1110:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! \b UDMA_INT_SW or \b UDMA_INT_ERR as documented for the function
1111:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! uDMAIntRegister().
1112:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
1113:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! \sa IntRegister() for important information about registering interrupt
1114:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! handlers.
1115:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
1116:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! \return None
1117:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //
1118:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //*****************************************************************************
1119:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** void
1120:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** uDMAIntUnregister(uint32_t ui32IntChannel)
1121:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** {
 1282              		.loc 1 1121 0
 1283              		.cfi_startproc
 1284              		@ args = 0, pretend = 0, frame = 8
 1285              		@ frame_needed = 1, uses_anonymous_args = 0
 1286 058c 80B5     		push	{r7, lr}
 1287              		.cfi_def_cfa_offset 8
 1288              		.cfi_offset 7, -8
 1289              		.cfi_offset 14, -4
 1290 058e 82B0     		sub	sp, sp, #8
 1291              		.cfi_def_cfa_offset 16
 1292 0590 00AF     		add	r7, sp, #0
 1293              		.cfi_def_cfa_register 7
 1294 0592 7860     		str	r0, [r7, #4]
1122:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
1123:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // Disable the interrupt.
1124:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
1125:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     IntDisable(ui32IntChannel);
 1295              		.loc 1 1125 0
 1296 0594 7868     		ldr	r0, [r7, #4]
 1297 0596 FFF7FEFF 		bl	IntDisable
1126:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
1127:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
1128:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // Unregister the interrupt handler.
1129:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
1130:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     IntUnregister(ui32IntChannel);
 1298              		.loc 1 1130 0
 1299 059a 7868     		ldr	r0, [r7, #4]
 1300 059c FFF7FEFF 		bl	IntUnregister
1131:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** }
 1301              		.loc 1 1131 0
 1302 05a0 0837     		adds	r7, r7, #8
 1303              		.cfi_def_cfa_offset 8
 1304 05a2 BD46     		mov	sp, r7
 1305              		.cfi_def_cfa_register 13
 1306              		@ sp needed
 1307 05a4 80BD     		pop	{r7, pc}
 1308              		.cfi_endproc
 1309              	.LFE20:
 1311 05a6 00BF     		.align	2
 1312              		.global	uDMAIntStatus
 1313              		.thumb
 1314              		.thumb_func
 1316              	uDMAIntStatus:
 1317              	.LFB21:
1132:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
1133:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //*****************************************************************************
1134:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //
1135:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! Gets the uDMA controller channel interrupt status
1136:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
1137:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! This function is used to get the interrupt status of the uDMA controller.
1138:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! The returned value is a 32-bit bit mask that indicates which channels are
1139:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! requesting an interrupt.  This function can be used from within an
1140:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! interrupt handler to determine or confirm which uDMA channel has requested
1141:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! an interrupt.
1142:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
1143:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! \note This function is only available on devices that have the DMA Channel
1144:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! Interrupt Status Register (DMACHIS).  Please consult the data sheet for
1145:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! your part.
1146:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
1147:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! \return Returns a 32-bit mask which indicates requesting uDMA channels.
1148:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! There is a bit for each channel, and a 1 in a bit indicates that channel
1149:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! is requesting an interrupt.  Multiple bits can be set.
1150:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //
1151:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //*****************************************************************************
1152:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** uint32_t
1153:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** uDMAIntStatus(void)
1154:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** {
 1318              		.loc 1 1154 0
 1319              		.cfi_startproc
 1320              		@ args = 0, pretend = 0, frame = 0
 1321              		@ frame_needed = 1, uses_anonymous_args = 0
 1322              		@ link register save eliminated.
 1323 05a8 80B4     		push	{r7}
 1324              		.cfi_def_cfa_offset 4
 1325              		.cfi_offset 7, -4
 1326 05aa 00AF     		add	r7, sp, #0
 1327              		.cfi_def_cfa_register 7
1155:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
1156:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // Return the value of the uDMA interrupt status register
1157:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
1158:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     return(HWREG(UDMA_CHIS));
 1328              		.loc 1 1158 0
 1329 05ac 034B     		ldr	r3, .L92
 1330 05ae 1B68     		ldr	r3, [r3]
1159:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** }
 1331              		.loc 1 1159 0
 1332 05b0 1846     		mov	r0, r3
 1333 05b2 BD46     		mov	sp, r7
 1334              		.cfi_def_cfa_register 13
 1335              		@ sp needed
 1336 05b4 5DF8047B 		ldr	r7, [sp], #4
 1337              		.cfi_restore 7
 1338              		.cfi_def_cfa_offset 0
 1339 05b8 7047     		bx	lr
 1340              	.L93:
 1341 05ba 00BF     		.align	2
 1342              	.L92:
 1343 05bc 04F50F40 		.word	1074787588
 1344              		.cfi_endproc
 1345              	.LFE21:
 1347              		.align	2
 1348              		.global	uDMAIntClear
 1349              		.thumb
 1350              		.thumb_func
 1352              	uDMAIntClear:
 1353              	.LFB22:
1160:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
1161:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //*****************************************************************************
1162:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //
1163:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! Clears uDMA interrupt status
1164:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
1165:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! \param ui32ChanMask is a 32-bit mask with one bit for each uDMA channel.
1166:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
1167:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! Clears bits in the uDMA interrupt status register according to which bits
1168:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! are set in \e ui32ChanMask. There is one bit for each channel. If a a bit
1169:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! is set in \e ui32ChanMask, then that corresponding channel's interrupt
1170:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! status will be cleared (if it was set).
1171:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
1172:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! \note This function is only available on devices that have the DMA Channel
1173:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! Interrupt Status Register (DMACHIS).  Please consult the data sheet for
1174:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! your part.
1175:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
1176:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! \return None
1177:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //
1178:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //*****************************************************************************
1179:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** void
1180:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** uDMAIntClear(uint32_t ui32ChanMask)
1181:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** {
 1354              		.loc 1 1181 0
 1355              		.cfi_startproc
 1356              		@ args = 0, pretend = 0, frame = 8
 1357              		@ frame_needed = 1, uses_anonymous_args = 0
 1358              		@ link register save eliminated.
 1359 05c0 80B4     		push	{r7}
 1360              		.cfi_def_cfa_offset 4
 1361              		.cfi_offset 7, -4
 1362 05c2 83B0     		sub	sp, sp, #12
 1363              		.cfi_def_cfa_offset 16
 1364 05c4 00AF     		add	r7, sp, #0
 1365              		.cfi_def_cfa_register 7
 1366 05c6 7860     		str	r0, [r7, #4]
1182:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
1183:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // Clear the requested bits in the uDMA interrupt status register
1184:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
1185:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     HWREG(UDMA_CHIS) = ui32ChanMask;
 1367              		.loc 1 1185 0
 1368 05c8 034A     		ldr	r2, .L95
 1369 05ca 7B68     		ldr	r3, [r7, #4]
 1370 05cc 1360     		str	r3, [r2]
1186:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** }
 1371              		.loc 1 1186 0
 1372 05ce 0C37     		adds	r7, r7, #12
 1373              		.cfi_def_cfa_offset 4
 1374 05d0 BD46     		mov	sp, r7
 1375              		.cfi_def_cfa_register 13
 1376              		@ sp needed
 1377 05d2 5DF8047B 		ldr	r7, [sp], #4
 1378              		.cfi_restore 7
 1379              		.cfi_def_cfa_offset 0
 1380 05d6 7047     		bx	lr
 1381              	.L96:
 1382              		.align	2
 1383              	.L95:
 1384 05d8 04F50F40 		.word	1074787588
 1385              		.cfi_endproc
 1386              	.LFE22:
 1388              		.align	2
 1389              		.global	uDMAChannelAssign
 1390              		.thumb
 1391              		.thumb_func
 1393              	uDMAChannelAssign:
 1394              	.LFB23:
1187:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
1188:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //*****************************************************************************
1189:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //
1190:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! Assigns a peripheral mapping for a uDMA channel
1191:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
1192:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! \param ui32Mapping is a macro specifying the peripheral assignment for
1193:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! a channel
1194:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
1195:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! This function assigns a peripheral mapping to a uDMA channel.  It is
1196:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! used to select which peripheral is used for a uDMA channel.  The parameter
1197:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! \e ui32Mapping should be one of the macros named \b UDMA_CHn_tttt from the
1198:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! header file \e udma.h.  For example, to assign uDMA channel 8 to the
1199:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! UART0RX channel, the parameter should be the macro \b UDMA_CH8_UART0RX.
1200:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
1201:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! Please consult the cc2538 data sheet for a table showing all the
1202:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! possible peripheral assignments for the uDMA channels for a particular
1203:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! device.
1204:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
1205:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! \note This function is only available on devices that have the DMA Channel
1206:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! Map Select registers (DMACHMAP0-3).  Please consult the data sheet for
1207:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! your part.
1208:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //!
1209:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //! \return None
1210:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //
1211:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** //*****************************************************************************
1212:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** void
1213:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** uDMAChannelAssign(uint32_t ui32Mapping)
1214:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** {
 1395              		.loc 1 1214 0
 1396              		.cfi_startproc
 1397              		@ args = 0, pretend = 0, frame = 24
 1398              		@ frame_needed = 1, uses_anonymous_args = 0
 1399              		@ link register save eliminated.
 1400 05dc 80B4     		push	{r7}
 1401              		.cfi_def_cfa_offset 4
 1402              		.cfi_offset 7, -4
 1403 05de 87B0     		sub	sp, sp, #28
 1404              		.cfi_def_cfa_offset 32
 1405 05e0 00AF     		add	r7, sp, #0
 1406              		.cfi_def_cfa_register 7
 1407 05e2 7860     		str	r0, [r7, #4]
1215:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     uint32_t ui32MapReg;
1216:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     uint32_t ui32MapShift;
1217:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     uint32_t ui32ChannelNum;
1218:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     uint32_t ui32Encoding;
1219:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
1220:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
1221:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // Check the parameters
1222:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
1223:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     ASSERT((ui32Mapping & 0xffffff00) < 0x00050000);
1224:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
1225:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
1226:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // Extract the channel number and map encoding value from the parameter.
1227:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
1228:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     ui32ChannelNum = ui32Mapping & 0xff;
 1408              		.loc 1 1228 0
 1409 05e4 7B68     		ldr	r3, [r7, #4]
 1410 05e6 DBB2     		uxtb	r3, r3
 1411 05e8 7B61     		str	r3, [r7, #20]
1229:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     ui32Encoding   = ui32Mapping >> 16;
 1412              		.loc 1 1229 0
 1413 05ea 7B68     		ldr	r3, [r7, #4]
 1414 05ec 1B0C     		lsrs	r3, r3, #16
 1415 05ee 3B61     		str	r3, [r7, #16]
1230:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
1231:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
1232:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // Find the uDMA channel mapping register and shift value to use for this
1233:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // channel
1234:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
1235:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     ui32MapReg = UDMA_CHMAP0 + ((ui32ChannelNum / 8) * 4);
 1416              		.loc 1 1235 0
 1417 05f0 7B69     		ldr	r3, [r7, #20]
 1418 05f2 DA08     		lsrs	r2, r3, #3
 1419 05f4 0E4B     		ldr	r3, .L98
 1420 05f6 1344     		add	r3, r3, r2
 1421 05f8 9B00     		lsls	r3, r3, #2
 1422 05fa FB60     		str	r3, [r7, #12]
1236:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     ui32MapShift = (ui32ChannelNum % 8) * 4;
 1423              		.loc 1 1236 0
 1424 05fc 7B69     		ldr	r3, [r7, #20]
 1425 05fe 03F00703 		and	r3, r3, #7
 1426 0602 9B00     		lsls	r3, r3, #2
 1427 0604 BB60     		str	r3, [r7, #8]
1237:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** 
1238:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
1239:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     // Set the channel map encoding for this channel
1240:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     //
1241:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****     HWREG(ui32MapReg) = (HWREG(ui32MapReg) & ~(0xf << ui32MapShift)) |
 1428              		.loc 1 1241 0
 1429 0606 FB68     		ldr	r3, [r7, #12]
 1430 0608 FA68     		ldr	r2, [r7, #12]
 1431 060a 1268     		ldr	r2, [r2]
 1432 060c B968     		ldr	r1, [r7, #8]
 1433 060e 0F20     		movs	r0, #15
 1434 0610 00FA01F1 		lsl	r1, r0, r1
 1435 0614 C943     		mvns	r1, r1
 1436 0616 1140     		ands	r1, r1, r2
1242:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****                         ui32Encoding << ui32MapShift;
 1437              		.loc 1 1242 0
 1438 0618 BA68     		ldr	r2, [r7, #8]
 1439 061a 3869     		ldr	r0, [r7, #16]
 1440 061c 00FA02F2 		lsl	r2, r0, r2
1241:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c ****                         ui32Encoding << ui32MapShift;
 1441              		.loc 1 1241 0
 1442 0620 0A43     		orrs	r2, r2, r1
 1443 0622 1A60     		str	r2, [r3]
1243:build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.c **** }
 1444              		.loc 1 1243 0
 1445 0624 1C37     		adds	r7, r7, #28
 1446              		.cfi_def_cfa_offset 4
 1447 0626 BD46     		mov	sp, r7
 1448              		.cfi_def_cfa_register 13
 1449              		@ sp needed
 1450 0628 5DF8047B 		ldr	r7, [sp], #4
 1451              		.cfi_restore 7
 1452              		.cfi_def_cfa_offset 0
 1453 062c 7047     		bx	lr
 1454              	.L99:
 1455 062e 00BF     		.align	2
 1456              	.L98:
 1457 0630 44FD0310 		.word	268696900
 1458              		.cfi_endproc
 1459              	.LFE23:
 1461              	.Letext0:
 1462              		.file 2 "/usr/arm-none-eabi/include/machine/_default_types.h"
 1463              		.file 3 "/usr/arm-none-eabi/include/sys/_stdint.h"
 1464              		.file 4 "build/OpenMote-CC2538_armgcc/bsp/boards/OpenMote-CC2538/source/udma.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 udma.c
     /tmp/ccOV9bJq.s:18     .text:0000000000000000 $t
     /tmp/ccOV9bJq.s:23     .text:0000000000000000 uDMAEnable
     /tmp/ccOV9bJq.s:51     .text:0000000000000014 $d
     /tmp/ccOV9bJq.s:55     .text:0000000000000018 $t
     /tmp/ccOV9bJq.s:60     .text:0000000000000018 uDMADisable
     /tmp/ccOV9bJq.s:87     .text:000000000000002c $d
     /tmp/ccOV9bJq.s:91     .text:0000000000000030 $t
     /tmp/ccOV9bJq.s:96     .text:0000000000000030 uDMAErrorStatusGet
     /tmp/ccOV9bJq.s:123    .text:0000000000000044 $d
     /tmp/ccOV9bJq.s:127    .text:0000000000000048 $t
     /tmp/ccOV9bJq.s:132    .text:0000000000000048 uDMAErrorStatusClear
     /tmp/ccOV9bJq.s:159    .text:000000000000005c $d
     /tmp/ccOV9bJq.s:163    .text:0000000000000060 $t
     /tmp/ccOV9bJq.s:168    .text:0000000000000060 uDMAChannelEnable
     /tmp/ccOV9bJq.s:203    .text:0000000000000084 $d
     /tmp/ccOV9bJq.s:207    .text:0000000000000088 $t
     /tmp/ccOV9bJq.s:212    .text:0000000000000088 uDMAChannelDisable
     /tmp/ccOV9bJq.s:247    .text:00000000000000ac $d
     /tmp/ccOV9bJq.s:251    .text:00000000000000b0 $t
     /tmp/ccOV9bJq.s:256    .text:00000000000000b0 uDMAChannelIsEnabled
     /tmp/ccOV9bJq.s:298    .text:00000000000000e0 $d
     /tmp/ccOV9bJq.s:302    .text:00000000000000e4 $t
     /tmp/ccOV9bJq.s:307    .text:00000000000000e4 uDMAControlBaseSet
     /tmp/ccOV9bJq.s:339    .text:00000000000000fc $d
     /tmp/ccOV9bJq.s:343    .text:0000000000000100 $t
     /tmp/ccOV9bJq.s:348    .text:0000000000000100 uDMAControlBaseGet
     /tmp/ccOV9bJq.s:375    .text:0000000000000114 $d
     /tmp/ccOV9bJq.s:379    .text:0000000000000118 $t
     /tmp/ccOV9bJq.s:384    .text:0000000000000118 uDMAControlAlternateBaseGet
     /tmp/ccOV9bJq.s:411    .text:000000000000012c $d
     /tmp/ccOV9bJq.s:415    .text:0000000000000130 $t
     /tmp/ccOV9bJq.s:420    .text:0000000000000130 uDMAChannelRequest
     /tmp/ccOV9bJq.s:455    .text:0000000000000154 $d
     /tmp/ccOV9bJq.s:459    .text:0000000000000158 $t
     /tmp/ccOV9bJq.s:464    .text:0000000000000158 uDMAChannelAttributeEnable
     /tmp/ccOV9bJq.s:545    .text:00000000000001cc $d
     /tmp/ccOV9bJq.s:552    .text:00000000000001dc $t
     /tmp/ccOV9bJq.s:557    .text:00000000000001dc uDMAChannelAttributeDisable
     /tmp/ccOV9bJq.s:638    .text:0000000000000250 $d
     /tmp/ccOV9bJq.s:645    .text:0000000000000260 $t
     /tmp/ccOV9bJq.s:650    .text:0000000000000260 uDMAChannelAttributeGet
     /tmp/ccOV9bJq.s:744    .text:00000000000002ec $d
     /tmp/ccOV9bJq.s:751    .text:00000000000002fc $t
     /tmp/ccOV9bJq.s:756    .text:00000000000002fc uDMAChannelControlSet
     /tmp/ccOV9bJq.s:811    .text:000000000000033c $d
     /tmp/ccOV9bJq.s:816    .text:0000000000000344 $t
     /tmp/ccOV9bJq.s:821    .text:0000000000000344 uDMAChannelTransferSet
     /tmp/ccOV9bJq.s:986    .text:0000000000000444 $d
     /tmp/ccOV9bJq.s:990    .text:0000000000000448 $t
     /tmp/ccOV9bJq.s:995    .text:0000000000000448 uDMAChannelScatterGatherSet
     /tmp/ccOV9bJq.s:1092   .text:00000000000004cc $d
     /tmp/ccOV9bJq.s:1096   .text:00000000000004d0 $t
     /tmp/ccOV9bJq.s:1101   .text:00000000000004d0 uDMAChannelSizeGet
     /tmp/ccOV9bJq.s:1160   .text:0000000000000514 $d
     /tmp/ccOV9bJq.s:1164   .text:0000000000000518 $t
     /tmp/ccOV9bJq.s:1169   .text:0000000000000518 uDMAChannelModeGet
     /tmp/ccOV9bJq.s:1233   .text:0000000000000568 $d
     /tmp/ccOV9bJq.s:1237   .text:000000000000056c $t
     /tmp/ccOV9bJq.s:1242   .text:000000000000056c uDMAIntRegister
     /tmp/ccOV9bJq.s:1280   .text:000000000000058c uDMAIntUnregister
     /tmp/ccOV9bJq.s:1316   .text:00000000000005a8 uDMAIntStatus
     /tmp/ccOV9bJq.s:1343   .text:00000000000005bc $d
     /tmp/ccOV9bJq.s:1347   .text:00000000000005c0 $t
     /tmp/ccOV9bJq.s:1352   .text:00000000000005c0 uDMAIntClear
     /tmp/ccOV9bJq.s:1384   .text:00000000000005d8 $d
     /tmp/ccOV9bJq.s:1388   .text:00000000000005dc $t
     /tmp/ccOV9bJq.s:1393   .text:00000000000005dc uDMAChannelAssign
     /tmp/ccOV9bJq.s:1457   .text:0000000000000630 $d
                     .debug_frame:0000000000000010 $d
                           .group:0000000000000000 wm4.0.59116071098782a37a9183a8102fe91b
                           .group:0000000000000000 wm4.hw_sys_ctrl.h.39.50b4d7775c38e82076d0eb3bdc2daf82
                           .group:0000000000000000 wm4.hw_udma.h.39.264bcf912c9ca2a6a4c20ac52cfd6e50
                           .group:0000000000000000 wm4.hw_udmachctl.h.39.691b4def60389db06f6fa18129325381
                           .group:0000000000000000 wm4.features.h.22.2e382148a0560adabf236cddd4e880f4
                           .group:0000000000000000 wm4._default_types.h.15.933e8edd27a65e0b69af4a865eb623d2
                           .group:0000000000000000 wm4._intsup.h.10.35a45952db64d30146faa63a55c20c1c
                           .group:0000000000000000 wm4._stdint.h.10.f76354baea1c7088202064e6f3d4f5e3
                           .group:0000000000000000 wm4.stdint.h.23.373a9d32a9e4c2e88fd347156532d281
                           .group:0000000000000000 wm4.stdbool.h.29.1c9ee6859ce8145f7838a4f2549ccec2
                           .group:0000000000000000 wm4.hw_types.h.67.b10589a0806dcc2d274d6fab6b736519
                           .group:0000000000000000 wm4.interrupt.h.41.272fc4ec0e276feb439e7974d0f77eaf
                           .group:0000000000000000 wm4.udma.h.41.9638b4921f2086b7874ec413c0bf6e00

UNDEFINED SYMBOLS
IntRegister
IntEnable
IntDisable
IntUnregister
